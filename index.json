[{"categories":["Lifestyle"],"contents":"做应用多少会接触到 GUI、图像相关的内容，这些领域都蕴含了深厚的内容，本文就从应用软件开发者的角度谈谈图形界面和图像。\n\rCairo on WinCE\r GUI 图形用户界面，大部分应用程序的界面都是由操作系统的 GUI 创建的，也有一些是自己生成的，后者一般自带了界面图形引擎，其绘图能力及界面描述部分都不依赖操作系统，在各种平台都有一致的表现（前面提到的 Flutter 就属于这一类），不过人机交互的信息输入及展示内容的承载还得依赖操作系统，也就是说它依赖鼠标、键盘、触屏、语音等输入设备和事件管理，在展示方面 App 也需要一个承载其内容的 Window 或是 Activity 才能将界面图形引擎创建的图像显示出来，音频信息输出内容也得依赖系统的声音设备。\n在早期 Windows CE/Mobile 的时代，系统 GUI 的图形能力相对单纯，绘制线条、填充平面、解码及渲染图片、解析及渲染字体（显示文本）这些能力就能创建基础的图形界面，很多的早期的图形界面都分解为这些基础的图形元素构成。而一些比较深度的能力像曲线、绘图抗锯齿、复杂梯度填充、图像透明（Alpha）通道、字体的 Style 等等，GUI 要么不关注要么 API 零散难用，对界面质量有要求的 App 则要自己实现。\n在我的印象里，那个时期 Microsoft 对于界面的图像质量似乎不太关心。灰色的界面、凸起的按钮、死板的列表。。。似乎应用程序的界面都是这样，只能这样。一些追求变化和体验的 App 直接从 Win32 SDK 出发，自己处理背景，自己绘制控件，自己去实现交互动画，孜孜不倦的打造精致的应用程序。那时有让开发者津津乐道的 GDI 双缓冲还有 DDraw 界面动画，甚至有开发者试图设计基于 XML 描述的图形界面自动生成系统，而这一切 Microsoft 似乎无动于衷，或许他是投入 .NET，在酝酿一次更彻底的变革吧。\n在那样的背景下公共的图形界面库显得格外引人注目，有流行的 QT 也有很少被提到的 GTK，使用这些库不需要依赖操作系统的 GUI 就可以创造漂亮的图形界面，这些库还可以通过源代码移植的方式来实现跨平台，而且有的开源库官方就提供了不同系统平台的版本，对于 App 开发者来说那是一次迁移永久收益。我也曾将 GTK 的图形核心 Cairo 移植到 Windows CE 上，封面图片是一个绘图演示，理论上可以拓展为一套独立可控的界面图形系统，不过我觉得图形系统不是一个人一个团队或是一个小公司能够玩得起来的。另外一方面，引入 Web 技术的 Hybrid 跨平台应用程序框架也初具雏形。\nAndroid 的出现打破了这一局面，Skia 图形引擎在直接将高质量的图形界面带到了人们的面前，除了丰富的绘图能力外还支持模糊、阴影等界面图像处理，对图像资源的支持也非常友好，能自动适应设备屏幕做插值（缩放）处理，而且还内置了基于 XML 的界面描述，不需要软件参与绘图，编写 XML 就能创建高质量的图形交互界面，更让人兴奋的是界面交互也非常流畅。\n移动端操作系统平台迅速从 Windows 时代跨越到了 Android 和 iOS 的时代，接下来，开发者已经不需要思考如何去加入一些绘图能力来提升界面交互的体验，也不需要思考如何设计一套界面描述机制将软件逻辑和界面绘图分离，App 只需要把注意力放在本身的创造上即可，其他事情交给操作系统。而 QT 一类的原生图形界面库却坚持了下来，延续至今作为各种平台可选的界面组件。\n过去的十年，平台应用程序的图形界面从操作系统 GUI 到公共界面组件再到混合模式，经历了几代的跨越。而引入 Web 技术，更关注跨平台和可描述性的 Hybrid 框架在近些年取得了快速发展，从早期的基于浏览器的雏形到现代复杂的原生“容器”设计，甚至对接图形加速接口，框架越来越高效，架构越来越先进，该模式越来越显现出未来主角的特质。\n图像 GUI 的目标是在屏幕上生成一副图像，向人类展示一些信息，根据交互来更新那幅图像。要说图形是描述，告知机器如何产生图，那么图像则是呈现，直观的可见的图。如果你是一名专业开发者，我不建议你将图形和图像混为一谈，因为“图形”和“图像”是不同的概念，技术上两者的交集也不广泛。\n很多时候，图像技术是用来存储和分享影像信息，摄像头采集下图像后将其压缩存储为 JPEG 图片文件，将文件传输到另外一个设备，它上面的照片程序开打图片解码显示图片，完成一个影像信息存储和分享的过程。图像压缩在图像的存储和传输中起着重要作用，图像信息数据量很大，压缩能有效减少存储消耗并提高信息传输效率。\nJPEG 格式对色彩丰富而且离散的图（如自然风景照片）有着很好的压缩效果，即便是图像信息损失的情况下也能保持很好的视觉感知。而色彩不多且变化又不频繁的图（如界面屏幕截图）则更适合用 PNG 格式压缩，这种场景下它能用较低的存储空间存储所有的图像信息。GIF 格式很老了，放到现代来说它能够高效编码的影像范围已经比较狭窄，不过它支持多帧并且受到浏览器等应用的广泛支持所以仍然用在动图场合。TIFF 则对图像信息准确性敏感，一般用在无损图像的场景里。当然了，还有不少图像格式用在比较专业的场合。\n图像编解码格式都有对应的 Codec，如 libjpeg、libpng、libtiff 等等，操作系统会集成一些常用的 codec 并提供 API 以支持一些图像相关的应用。专业的图像处理应用则会自带很多的 Codec，以广泛的支持各种图片格式。除了专注于图像编解码算法外 Codec 还关注编解码运算的硬件加速，因为图像的编解码也是运算量不小的任务。\n近些年图像技术已经不仅仅用来存储和分享影像信息，以前图是给人看的，现在人类也试着让机器看图。最常见的就是二维码扫描，A 设备通过二维码算法将文本信息编码为二维码图像并显示，然后 B 设备通过摄像头采集并分析图像得到文本信息，完成机器“看图”的过程，即通过图像生成和图像分析技术实现了文本信息从 A 设备传递到了 B 设备。\n类似的技术也有图像文本识别和基于 AI 的图像分析，从人机交互的维度看这是一项质的飞跃。以前，人类需要看 A 设备上的文本然后输入到 B 设备，需要记忆文本然后小心翼翼的输入文本，事实上信息是从 A 传递到了人脑再从人脑传递到 B。而现在，人类只需要将 B 的摄像头对着图像即可，其他的事情交给机器去完成。\n当代，基于 AI 的图像技术应用有着革新人机交互的趋势。我觉得 Google 眼镜是个有些超前时代产品，结合图像、AI、大数据和智能化的人机交互的应用未来还会出现。《钢铁侠》大胆的想象了人类和机器的交互方式，跳出屏幕和 Touch 的束缚，跳出距离的限制，语音、机器视觉、机器智能、大数据或许可以成为新一代智能设备 GUI 想象的起点。\n","permalink":"https://xinlake.dev/blog/2021/01-gui-and-image/","tags":null,"title":"GUI 和图像"},{"categories":["Lifestyle"],"contents":"2020 年初我在朋友圈发了这样一段话（略有编辑）：Application 的三种形态 Native、Web、Hybrid 很早就提出来了，其中 Hybrid 型态因其跨平台特性和能够轻松创建一致的 UI 体验而备受关注，催生了不少框架。但是，一个框架要成为标准，要发展出生态，那是个漫长的过程。混战近十年，小框架要么死要么合并，有大平台烧钱的才能支撑下来。Microsoft 很早就涉入了 Hybrid 框架，与 Facebook、Google 等后起之秀并存至今，你要是常看电影可能一眼就能觉察到谁是影片的主角或是主角之一，所以，我觉得现在可以跟着 Google 折腾一下 Flutter。\n于是，我便在业余时间里学习了 Flutter。我觉得学习的意义是在于明白 Flutter，形成一个有效的认知，在实际使用时知道如何使用其能力，能够在架构层面应用 Flutter 设计跨平台的现代应用程序，以至于对应用程序的用户体验、效率、生产力等起到正面的促进作用。\n1，初见 通读官方（英文）原文文档，Flutter 一遍，Dart 一遍。基本上都是在早上，用手机打开官方网站阅读其文档资料。Google 还专门对不同平台的开发者写了迁移指引，像 Android 平台，文档就介绍到原生 App 里的 View 和 Flutter 里的 Widget 最接近，这些文档可以让其他平台的开发者更容易上手。对于 Android 或 Web 开发者而言，大部分的知识都已经具备了，读一遍文档大概一周就可以完成。\n读完文档其实没多久就忘了，不过，能读懂能读完说明能继续往下走，用到时查阅即可。如果读不懂文档那可能很难继续，应该先提升一下技术知识。\n第一个演练是官方样例，准备环境、创建项目、运行都一切顺利，体验 Hot Reload，感觉很不错。我是走国际线路来安装环境的，Flutter 有国内镜像，但是国内网络有点复杂，我甚至换一家咖啡店就没法访问 Flutter 的国内镜像，所以 Flutter 的开发就一直走了国际线路。\n有印象的是调整 Flutter 项目的目录结构，Flutter 项目的目录结构比 Android 原生 App 项目多一层，即顶层是 Flutter 项目，然后里头包含了 Dart 源代码和 Android、iOS、Windows 等平台子项目。对于 Android 开发者而言这种结构看着有些奇特，于是费了一下午的力气修改 Gradle 构建脚本使 Flutter 和 Android 在同一层，结果，VSCode 或是 Android Studio 调试 Dart 时均无法构建 App，仅能从 Android 子项目构建 App。Google 了很多资料经过多方确认得知项目有些路径都是固定的，构建环境根本没有完全按脚本来配置，有些只能按照默认的来。\n调整目录结构的想法就此搁置，为了让项目模块化一些，后来想了个办法，把平台代码封装放到 Android AAR 里给 Flutter 的 Android 模块调用，以实现目录结构不受 Flutter 工程的影响。\n\rFlutter 列表，数据均由程序随机生成\r 2，演练 此前做过一个 Shadowsocks Android 的定制版，后来没有维护了，因为要用 Flutter 全新设计一个 App。这个 App 会有一个比较复杂的列表，列表展示数据库的数据，需要能够支持添加数据、删除数据、修改数据，交互上还要有调整显示顺序、选择 Item 的功能，此外还得设计一个空数据时的交互界面，接下来的深入学习和演练都是围绕这个列表和数据库而展开。\n数据库我用的 AndroidX Room 组件，它封装了 SQLite 的一般操作并且支持 DAO（数据访问对象），通过类和注解就可以创建数据表或建立关系表还可以完成一般的数据存取，不需要写 SQL 语句。其实 Flutter 也有 SQLite 插件（Flutter 的插件后面还会提到），但是不支持 DAO，所以我的设计方案是将数据库操作放到 Android 平台，通过 Flutter 平台通道来传递数据交互。\n这样的方案把 Flutter 的很多组件都涉及到了，包括平台通道、动态、异步、布局等，在官方文档和 Google 搜索的帮助下用了数天的下班时间最终实现了这个方案，数据库和交互均符合预期。感触不少：Flutter 的异步（await, async）感觉真是太熟悉了，关键字及用法都和 C# 里一样；dynamic 和 object 不好理解，刚开始很难判断该用 dynamic 还是 object；用下划线“_”省略参数真是一种难看的设定，和 Kotlin 一样难看。。。不过最有映像是框架的效率，我用几年前的手机跑 Debug 版本也很流畅。\n3，一个月 将列表的实现完善、整理并封装其实就完成了一半的交互界面了，剩余的部分都比那个列表要简单很多。所以，接下来的工作就以平台通道为桥梁，拓展交互界面和平台能力实现。理论上 Dart 界面部分是跨平台通用的，而 App 能力或 API 调用则依托于操作系统平台，这可以为 App 后续跨平台打下基础，在不同的系统平台上实现同样的能力，而又不影响 App 架构。现在，我的这种“下班工作”已持续近一个月。\nFlutter 设计了 StreamBuilder、FutureBuilder 来支持 UI 异步更新，而 Android 原生做异步更新可能是 AsyncTask 或运行 Thread 完事后调用 runOnUiThread 等方式，Flutter 这种没接触过的全新组件也让我走了一些弯路，不好判断使用场景，以至于在不必要的场景使用了异步组件。后来在 Stackoverflow 上看到一个回答总结的很好，大意是说 StreamBuilder 用于持续性数据更新，而 FutureBuilder 适用于一次性的数据更新。其实组件名称早就说明了，一个是 Stream 一个是 Future。\n我在列表上方放了一个图表 Widget，以实时显示设备的网络流量，数据由 Android 平台端主动更新并发给 Flutter 显示。起初是在页面订阅平台通道事件并控制 Widget 更新，这使得页面的刷新愈加复杂，也是在这个时候，发现页面中的一个 Widget 调用 setState 刷新整个页面时可能会打断另一个 Widget 正在进行的界面交互。即当我拖动列表项试图调整排序时，来自 Android 平台端的流量数据更新会中断我列表项的拖动。\n后来把平台通道的事件订阅交给图表 Widget，让 Widget 自己管理其状态和刷新即完美解决。其实中途还尝试让“控制点”使用 Widget 的 Key 来更新数据，打断交互问题解决了但是 Widget 不显示的时候也被控制更新数据，总之那种设计和框架不是那么契合吧。这也很自然，至少在这个有点特别的场景里，以往“控制点”的思路不合适，新事物有它自己的 Style。\n\r下班工作\r 4，三个月 接下来的几周陆续添加了 CameraX、ZXing、MLKit、GeoLocation 等功能模块，交互界面新增支持了 Light、Dark 模式，可以跟着系统自动切换也可以手动控制，此外还设计了 App 大致的页面结构，一个 Flutter App 大致成型，当然，不少 Native 层的模块需要添加，也有很多细节需要处理。\n这里顺便说一下 Android 的摄像头 API，Android 目前有 Camera、Camera2、CameraX 三种 API。其中，Camera 已不推荐使用，它比较老旧有些新的硬件特性可能无法使用或伴随性能问题；Camera2 是 Android 5.0 新加入的 API，能更好的使用硬件能力和提供更好的性能，但是 Camera2 变化较大而且使用繁琐；CameraX 是 Android Jetpack 的一部分，Google I/O 2019 提出的最新的摄像头 API，它具备 Camera2 的特性而且对开发者也更加友好。\nCameraX 能很好的对接图像处理模块，如 ZXing、MLKit 等或是开发者的图像处理算法。我的 App 也是这种模式，CameraX 加 ZXing 或 MLKit 图像分析来实现扫码能力。不过交互上是 Flutter 通过平台通道打开一个 Activity 来做这些事情，其实应该要用 PlatformView 更合适，总之有不少可以优化的地方吧。\n随着逐步改进和优化，时间来到了三个月，感觉 Dart 和 Java 在编程上有个不一样的地方，在大的编程思路上 Dart 更倾向于面向过程，可以轻松的通过全局变量和函数来组织页面，而 Java 等面向对象编程则倾向于使用抽象和对象的关系来描述事物。三个月，回顾过往，发现不知不觉写了几千行的 Dart，现在，用 Flutter 设计及开发 App 已经不是问题。\n5，Flutter Windows 应用 2020 年 9 月份，Google 发布了 Flutter for Windows Desktop 的 Alpha 版本，也就是说可以用 Flutter 开发 Windows 桌面应用程序了，将 Flutter SDK 切换到 Dev 通道即可创建支持 Windows 平台的 Flutter App。如果需要让 App 支持 Windows 平台，在 Windows 上实现相应的功能即可，Dart 部分是通用的而且在各个平台上也有一致的 UI 呈现和交互体验。\n当然，不同的屏幕（信息输出）和不同的信息输入方式（触屏、鼠标、键盘）在交互上给人感知和体验是不一样的，Flutter App Dart 部分虽然通用，但是也得根据屏幕和设备类型在交互上做适当的适配。\n在发布 Alpha 的同时官方也给出了一个 Flutter Windows Demo 软件，我体验了一下感觉很不错，运行 Demo 并不需要任何运行库或是虚拟机，App 应该算是 Win32 SDK 原生 Windows 应用程序，稳定而且效率很好。引人注意的是在任务管理器里能看到 App 能将图形部分的计算交给 GPU，UI 变化时能看到 App 的 GPU 使用也会发生变化，其实，Flutter 是做了不少图形相关的工作才让它具备了这一让人兴奋的特性。总的来说，Alpha 就给到了开发者很大的迁移动力。\n我试着将之前的一个 Windows .NET WPF 开发的小程序用 Flutter 重构，感觉开发上和 Android 没什么差别，编写 Dart 只需要关注 UI，不用关心是什么操作系统，而系统平台相关部分由平台层处理。\n\rFlutter Windows\r 6，插件和生态 Flutter 的插件能够让 App 轻松扩展功能或是和操作系统进行交互，但是目前来看却不是那么美好。开发者封装一些平台实现代码及 Dart 代码并打包为插件发布，让其他开发者直接使用，这样可以提升开发效率。但是，引入插件较多时会让 App 的模块化组织混乱：一方面，各插件功能可能会有重叠部分，每个插件都创建平台通道会带来不合理的资源开销；另外一方面，各插件的依赖项可能引起冲突，插件指定的构建工具版本零散，这些都会给 App 的构建带来难以预测的结果。\n尤其对于系统平台较为生疏的开发者，依赖大量的插件可能是让人沮丧的，如果对平台原生开发熟练，能自己管理平台端实现及数据通讯，那么插件可能就没什么意义。起初，我也引入了一些插件，结果发现那些插件只是封装一些简单的 Android 原生代码，然后就完全放弃了插件，自己建一套平台交互机制。Dart Package 则较为单纯，不会有什么影响。\n有人评价 Flutter 的生态不好，而我觉得现在去评价 Flutter 的生态为时尚早。Android 系统在 2.x 才有一个相对稳定的状态，到了 5.x 才开始有了比较明朗的发展线路。Flutter 的插件生态我估计后续可能会有比较大的变化，就目前而言，有很多开发者参与我觉得就是一种健康的状态。\n7，2021 回顾 2020，如果要说最大的收获那应该是：掌握了 Flutter，掌握了现代跨平台应用程序的设计和开发，能够连接未来新一代移动应用技术主线，驾驭创新。\n2020 不容易，2021 希望能够助你乘风破浪，所向披靡！\n","permalink":"https://xinlake.dev/blog/2021/01-the-story-in-2020/","tags":["Flutter"],"title":"2020 故事，学习 Flutter"},{"categories":["Lifestyle"],"contents":"这是第三次站点更新，刚开始是 Hexo 和默认模板定制，然后切换到了 Hugo 并用 Bootstrap 开发模板 Blog v2，这一次是在 v2 的基础上做改进。Web 页面模板的更新不像软件那样有着明确的版本号和意义，页面模板的变动很多是展现形式上变动，我觉得用 v2.1 这种宽泛的版本或代号可以形容改动量。当然了，最大的变化就是启用了新的域名。\n买下这个域名到现在有半年多时间了，本来打算五一假期启用新域名，不过新名称总有着一种新开始的展望，于是就做了一次升级，但是升级工作没做完五一假期就结束了，随即把升级的事情安排到了十一，今年的国庆中秋有八天假期，这个时间足够开发一个静态网站了。\n设计了新的首页面，现在首页可以看到最近的文章还有开发的东西，有新的变化都会在首页呈现。关于内容也移到了首页，被放到了页面的底部，原先的 Timeline 拿掉了，站点变化可以通过 Blog 标签来追踪。博客移到了 Posts 菜单下，当然，首页的最新文章可以直接打开。菜单上还有个博客目录 Archive，这里可以检索到所有文章。\n出于加载速度的原因，我把评论系统换成了全球广泛使用的 Disqus，其实我对来必力的看法是正面的，它是少有的自有灵魂的产品。现在评论是国际网络下的专属内容，页面在国内通用网络下不加载评论，而在国际网络下你会看到评论互动。\n\r左边通用网络，右边国际网络\r 细节就不壹壹介绍了，有一些变化不明显，像文章版面的宽度变小了，这样阅读体验会更好。有一些优化你可能感受不到，像页面插图下方的 Label 之前是靠页面 JS 生成，而现在是一步到位模板直接渲染出带 Label 的插图。总之是坚持技术正确和先进，很高兴认识你！\n","permalink":"https://xinlake.dev/blog/2020/11-blog-v2.1/","tags":["Blog"],"title":"Blog v2.1"},{"categories":["Network"],"contents":"XTransmit 项目更名为 Privch，因为 XTransmit 这个名称的 com 域名已经被注册了。我是 2019 年 08 月份开源的，10 月份发了第一个 Release，前不久准备注册域名查了一下发现 xtransmit.com 已经在 2019 年 12 月被人注册了。注册商显示为 godaddy，我通过 godaddy 尝试和域名注册者取得联系，问对方是否愿意转让，可是没有得到任何回应，无奈只好放弃原名称。不过，新的名称 Privch 意义更为准确，也更加友好。\n\rPrivch 0.9.0\r \r原名称已被注册\r 上图是 ICANN 查询 xtransmit.com 域名的信息，注册时间为 2019-12-30。这次更新是一些修复和调整，版本号原先是 0.8.1，由于更新名称版本号升到 0.9.0。此外，项目相关的仓库都将移到 Privch 下，GitHub 会重定向旧仓库的访问，不过最好更新一下 git remote url。\n修复了一个替换服务器时的状态同步问题，Privch 的服务器列表没有重复项，当（扫码、导入等）添加的服务器已经存在时 Privch 会替换旧的服务器。新版本修复了连接状态同步的问题，当这个服务器当前正在被使用时，程序会使用新的参数重新连接服务器。\n提升了单实例功能，Privch 的主要作用是提供服务，不会运行多个进程。当程序已经在运行时，再次启动程序则会（通过进程间管道通信）显示已运行程序的主界面，不会运行一个新的进程。\n随着引入库的增加，关于界面越来越长了，现在关于界面里已将 opensouce software 移到另外的界面里显示了。同样的，如果发现有什么问题希望能够得到你的反馈，通过 GitHub Issues 或是本文下方的评论都可以。\n","permalink":"https://xinlake.dev/blog/2020/04-privch-0.9.0/","tags":["Privch","Shadowsocks","V2Ray","XTransmit"],"title":"Privch 0.9.0"},{"categories":["Network"],"contents":"这次更新做的是减法，XTransmit 0.8.0 移除了自定义数据传输模块，移到另外一个工程去了。那个模块通常用于绕过前端页面直接向目标站点发送特定功能的数据包（如评论、点赞、阅读数等等），和主要功能交集不多，移除之后程序会变小。\n\rXTransmit 0.8.0\r 不过这次更新也提供了一种外部程序使用国际线路的方式，XTransmit 添加了一个 HTTP 服务以向外部程序回应国际线路的本地接口，软件访问 http://127.0.0.1:44100 可以获得线路的本地接口信息，然后设置通讯代理让数据走国际线路。用浏览器打开也可以看到接口信息，如上图所示。向该地址发送 GET、POST 请求都可以，XTransmit 没有判定请求类型会直接回应数据，下面是 C# 参考代码\nstatic readonly HttpClient httpClient = new HttpClient { Timeout = TimeSpan.FromMilliseconds(1000), }; HttpResponseMessage response = httpClient.GetAsync(new Uri(\u0026#34;http://127.0.0.1:44100/\u0026#34;)).Result; response.EnsureSuccessStatusCode(); string responseBody = response.Content.ReadAsStringAsync().Result; string[] servers = responseBody.Split(new string[] { \u0026#34;\\r\\n\u0026#34; }, StringSplitOptions.RemoveEmptyEntries); 每次请求都会回应最新的数据，最后获得的 servers 即是本地代理接口，数组每项都是一条国际线路（有单独的 IP）。一般情况下只会返回一个接口，不过当“服务池”开启时会返回很多（上图即是开启时的数据），可以任意使用，XTransmit 会维护这些线路。\n远端服务器连接性检测改进了测试方法，现在输出的响应时间是具有参考意义的。点击当前使用的服务器（如下图红框所示）即可对线路做连接性检测，程序会以本地设备发起请求为起点开始计时，到请求的内容传输到本地设备后停止计时，得出总的时间在界面底部显示。这和 ping 不一样，ping 的结果可以说明设备到远端服务器的网路是否畅通，但是远端服务器是否提供服务、负载情况、服务器之后的网络状况则不得而知。连接性检测类似于从在浏览器输入网址到看到页面的时间，包括网络状况、远端服务器、目标站点等都会对响应时间有影响。\n\r连接性测试（毫秒），我这的网络差时间较长\r 因为连接性检测的时间较长，当列表里有 10+ 个服务器时检测可能要几分钟，所以批量连接性检测操作就取消了。不过批量获取服务器信息、ping 没有取消而且还添加了多选支持，鼠标滑动选择多个服务器或是按住 Ctrl 点选多个服务器，然后在右键菜单里就可以操作。\n\r多选\r 此前服务器信息只用在了更新服务器名称（基于 IP 的地理位置），现在这个功能直接改为了“更新服务器名称”，功能上也没有打算在丰富服务器信息上做提升，取而代之的可能是丰富服务器连接性、延时等相关统计数据，我觉得引入神经网络让机器智能来选择线路是个不错的主意。\n希望疫情早日散去，春暖花开。\n","permalink":"https://xinlake.dev/blog/2020/02-xtransmit-0.8.0/","tags":["XTransmit","Shadowsocks","V2Ray"],"title":"XTransmit 0.8.0"},{"categories":["Network"],"contents":"XTransmit 0.7.0 新增了对 V2Ray 的支持并且继承了原有的界面及操作模式 ，从系统栏图标扫描屏幕二维码时可以自动识别服务器类别（Shadowsocks、V2Ray），并向对应的列表添加服务器。如果要从 Shadowsocks 线路切换到 V2Ray 线路，只需要双击 V2Ray 服务器即可，不需要任何额外的操作。\n\rXTransmit 0.7.0\r 主界面新增了 V2Ray 页面，你可以在这里添加、删除服务器及修改服务器配置，也可以进行一些服务器状态检测。服务器配置也同样的支持 V2Ray，会根据服务器类别调用相应的配置界面。当需要切换线路时，XTransmit 会自动关闭当前线路并且连接到远端服务器启用新线路，你可以轻松的在不同类别的线路中任意切换。\n新版本数据文件有所变动，添加了 V2Ray 数据文件 data\\ServerV2Ray.xml，Shadowsocks 数据文件则更改为 data\\ServerShadowsocks.xml。如需保留原 Shadowsocks 数据可以用文件编辑器（如 Notepad++）打开原数据文件 data\\Servers.xml 开启大小写匹配、全字匹配查找替换这些内容：ArrayOfServerProfile 替换为 ArrayOfShadowsocks；ServerProfile 替换为 Shadowsocks；HostIP 替换为 HostAddress。\n由于 V2Ray 服务的实现有可能架设 CDN，V2Ray 节点可能不会有明确的 IP 地址，所以 XTransmit 里基于 IP 的信息不会被包含在 V2Ray 服务器里，这一点会在未来的版本中改进。\n服务器响应时间检测做了少量改动，去掉了批量检测，现在点击主界面上的服务器名称（蓝色）即可。此外，为了方便引入其他模块我将 .NET Framewor 版本设为了 4.7.2。当然，新版本也修复了已经发现的问题。\n\rSetting 变化\r","permalink":"https://xinlake.dev/blog/2020/02-xtransmit-0.7.0/","tags":["cURL","Shadowsocks","V2Ray","XTransmit"],"title":"XTransmit 0.7.0 新增支持 V2Ray"},{"categories":["Network"],"contents":"从 XTransmit 0.6.0 开始不需要安装运行时库了，我也是偶然在一台新电脑上运行 XTransmit 才发现这个情况，开发用的电脑自带了运行时库，一切都很正常，而普通电脑系统则有可能弹出缺少运行时库的信息。\n\rXTransmit 0.6.0\r 这个状况出现在 XTransmit 用到的原生（C++）程序模块 ProxyCtrl 和 Prixvoxy 里，这两个程序都是默认动态链接运行时库，程序运行期间需要调用机器上的动态库（dll），如果机器上没有系统则会弹出相关信息。XTransmit 0.6.0 已经将两个模块的运行时库改为了静态链接，即将相关库的代码编译到程序里，不从机器上调用（不要求机器安装运行时库）。\n新版本添加了自动启动功能，你可以在设置里打开或者关闭它。启用该功能时软件会在用户的启动目录（Windows 10 默认路径是 C:\\Users\\[USER-NAME]\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup）创建一个快捷方式，当用户登录时操作系统就会运行软件，而关闭该功能时这个快捷方式则会被删除。\n添加了明亮界面主题，你可以在设置里进行主题切换。切换主题会作用到软件的全部界面，而且会即时发生变化，当然也会保存你的设置，软件下次会按照设置的主题启动。\n\rTheme\r 服务器列表添加了活动服务器指示、检测响应时间功能。现在列表会以活动色（紫色，活动色后续可能会跟随主题发生变化）标记正在使用的服务器，如下图所示。位于工具条右侧的“Check response time”可以测试服务器的响应时间，连同“获取服务器信息”和“检测 ping 延时”工具条上的按钮都是批量执行的，会对列表中的所有服务器进行检测（可以通过右上角的圆形进度条来停止后台检测任务），服务器的右键菜单则可以对选中的单个服务器执行检测。\n\r服务器列表\r 此外，服务器配置编辑中也加入这些检测按钮，位于编辑界面底部。这里会使用设置的数值（如 IP）进行检测，当进行某项检测时按钮会被锁定，同时按钮右边有个圆形进度条。\n\r服务器设置\r 添加了关闭 XCURL 窗口时的任务提示，以避免未存储的模板数据丢失。XCURL 的执行窗口也会在系统任务栏显示进度（下图底部），当关闭 XCRUL 时如果有未完成的任务就会给出提示，确认的话才会停止所有任务并丢弃所有的模板改变。\n\rXCURL 工具\r 新增的服务器响应时间检测功能其输出数据并不是很准确，这点将在未来的版本中得到改进。如果你发现了问题（包括 UI 语言表述）或是有任何想法都欢迎反馈，通过 GitHub Issues 或是本文下面的评论都可以。相关信息可以点击 XTransmit 标签。\n","permalink":"https://xinlake.dev/blog/2020/02-xtransmit-0.6.0/","tags":["cURL","Shadowsocks","XTransmit"],"title":"XTransmit 0.6.0"},{"categories":["Network"],"contents":"祝大家新春愉快，合家欢乐，事事顺心！XTransmit 0.5.5 做了一些改进，我觉得开始像个软件了。\n\rXTransmit 0.5.5\r 设置里添加了服务端口信息（下图），信息显示于设置界面右侧，显示的是软件本地代理服务的 HTTP、SOCKS5 端口。端口是自动设定的不用手动指定，如果端口被占用了 XTransmit 会自动查找可用端口，不会和其他软件、系统服务发生冲突。\n此外设置里还添加及一个“替换旧服务器”的选项，位于设置界面左下方，这个选项会在添加服务器时起作用。当启用该选项时，尝试添加的服务器已经存在的话（IP、Port 均一致）则会被替换，禁用时则会保留原有的服务器取消添加。不论是扫码、导入、还是手动添加都会根据这个选项来判断，XTransmit 的服务器列表没有重复项，这个选项可以很好的应对公共服务器密码等参数变动的情况。\n\r设置（是的，设置界面不太好看，不过这是暂时的)\r 后台任务新增了单独的进度指示及控制（上次更新提到过），执行获取服务器信息、Ping 服务器等任务时右上角会有个转动的圆形进度条，这个进度条的值（蓝色部分）会根据任务数量发生正比变化，即任务多时蓝色部分会变多，任务少的时候会变少。现在鼠标移到这个进度条上方时可以看到有多少个后台任务正在运行，点击进度条则可以看到每个任务的具体进度并且可以点击右侧的“停止”按钮来停止任务的执行，此外，鼠标移到具体任务的进度条上方时你还可以看到该任务的描述。\n\r后台任务\r IP 数据库（用于 X-CURL 模块）的 Ping 检测添加了停止操作，以前是关闭窗口时停止检测任务，现在点击右上方的圆形进度条就可以。当然了，网络操作很多都不可以中断，点击后需要完成当前检测才会停止，停止时间取决于网络状况、远端服务器、本地超时设置。\n\rIP 数据库\r XTransmit 会保存一些 UI 状态以便于下次以同样的状态打开界面，现在主界面的显示状态也已经加入其中。如果退出程序时主界面是关闭的（关闭主界面，点击系统栏图标退出），则下次启动时也是关闭的（仅有系统栏图标），反之亦然。\n这次更新还包含了一些小的变化：系统栏菜添加了几个菜单项；系统栏图标会根据服务状态来初始化图标；当列表锁定时添加服务器会给出提示；调整了少量的 UI 文字。如果你发现了问题（包括 UI 语言表述）或是有任何想法都欢迎反馈，通过 GitHub Issues 或是本文下面的评论都可以。\n\r系统栏图标\r","permalink":"https://xinlake.dev/blog/2020/01-xtransmit-0.5.5/","tags":["cURL","Shadowsocks","XTransmit"],"title":"XTransmit 0.5.5"},{"categories":["Network"],"contents":"XTransmit 0.5.4，这是一个维护性更新，更新了依赖的组件，修复了发现的问题，还做了少量的改进。\n\rXTransmit 0.5.4\r 数据文件夹名称由原来的“datas”改为了“data”，在软件关闭的状态下复制“datas”下的所有文件到“data”目录即可完成数据迁移，原“datas”文件夹将不再使用可以删除。\n获取服务器信息的功能做了改进但是旧的数据没有被保留，不过只需要点击工具条右侧的“获取”按钮即可完成数据更新。你可以进入服务器编辑界面（在服务器列表的右键菜单中选“Edit”，或选中服务器按“E”建）查看该服务器的信息，服务器信息位于编辑界面右侧。\n任务进度指示做了少量改进但是你可能看不出有什么变化，这是因为改进还没涉及到 UI 层面。软件的后台任务（如检测服务器 ping 值、获取服务器信息）均是在 .NET 管理的线程池中运行，每个任务都可以有进度并且可以被控制，任务进度指示在未来的版本中可能会长得和 Android Studio 里的差不多。\n","permalink":"https://xinlake.dev/blog/2019/12-xtransmit-0.5.4-cn/","tags":["XTransmit","Shadowsocks","cURL"],"title":"XTransmit 0.5.4"},{"categories":["Network"],"contents":"XTransmit 0.5.4, It is a maintenance release, upgraded dependencies, fixed known issues, and have made some improvements.\n\rXTransmit 0.5.4\r The data folder \u0026ldquo;datas\u0026rdquo; has been renamed to \u0026ldquo;data\u0026rdquo;, You can shut down program and copy all files under the \u0026ldquo;datas\u0026rdquo; folder to the \u0026ldquo;data\u0026rdquo; folder to migrate your data, The \u0026ldquo;datas\u0026rdquo; folder is no longer used you can delete it.\nThe fetch server infomation function has been improved and the old data is not retained, but you can easily update the server information by simply clicking the \u0026ldquo;Fetch\u0026rdquo; button on the right side of the toolbar. You can open the server edit view (select \u0026ldquo;Edit\u0026rdquo; from the right-click menu of the server list or select the server and press \u0026ldquo;E\u0026rdquo;) to see the server information, which is displayed on the right side of the view.\nProgress display has been improved but you may not feel any difference, this is because improvements have not touched the UI. Program background tasks (such as ping server, fetch server info) are run in a thread pool managed by .NET, each task has its progress and can be controlled, The progress UI in future release may looks like the progress view in Android Studio.\n","permalink":"https://xinlake.dev/blog/2019/12-xtransmit-0.5.4-en/","tags":["XTransmit","Shadowsocks","cURL"],"title":"XTransmit 0.5.4"},{"categories":["Network"],"contents":"Shadowsocks Android 修改版跟进到了 4.8.7，除了更新了依赖库版本和 TCP Fast Open（简称 TFO）选项的默认值之外没有其他变化。源码在这里 shadowsocks-android-modified，APK 可以在 GitHub Releases 里下载。\nTFO 功能原先在修改版中是开启的，这一点可能和官方的版本不一致，不过在这个版本中设为和官方版本一致了（默认关闭）。TFO 可能需要 Android Linux Root 身份才能操作，仅仅在软件中开启未必会有效果。关于 TFO 的细节有兴趣的朋友可以查阅一下 RFC7413。\n同样的，如果你发现问题或是有任何想法欢迎反馈，通过 GitHub Issues 或是本文下面的评论都可以。这个修改版 Android App 将在未来的 2 次更新之后再评估是否继续开放源码。\n","permalink":"https://xinlake.dev/blog/2019/12-shadowsocks-android-modified/","tags":["Shadowsocks"],"title":"Shadowsocks Android Modified v4.8.7"},{"categories":["Network"],"contents":"这是一个 Shadowsocks Android 的修改版，移除了广告，去掉了对 Google 服务的依赖并使用本地模块来支持必要的功能，去掉了 TV 模块、插件功能，简化了代理模式和相关的设置及数据。这个版本适用于经常连接公共服务器的情况，可以很好的在国内运行，源码在这里 shadowsocks-android-modified。\n\r XTransmit 计划里包含了 Android 移动应用，不过 Shadowsocks Android 修改版用着也不错就先把这个发出来。代码结构变化很大，原先的 plugin、core、mobile 都合并到一个 module 去了。Feature 减少了很多，以至于数据库和 Native SO 库都和原版不一样。加之少量的界面、逻辑改动，整个代码看起来变化不少。修改版可能会跟进官方的版本更新，当官方更新涵盖了修改版中的内容则会跟进，而不含有修改版的内容时（比如仅仅更新了 TV 模块）则不会跟进。\n事实上这个 App 我自己用了有数个月的时间，暂时未发现什么问题，如果你发现问题或是有任何想法欢迎反馈，通过 GitHub Issues 或是本文下面的评论都可以。这个修改版 App 目前正处于试开源阶段，计划做 3 个版本的更新，然后评估是否继续开放源码。（如果不开源则不会分发它。）\n","permalink":"https://xinlake.dev/blog/2019/10-shadowsocks-android-modified/","tags":["Shadowsocks"],"title":"Shadowsocks Android Modified v4.8.5"},{"categories":["Network"],"contents":"Privoxy 是具有高级过滤功能的非缓存 Web 代理（同类软件里分缓存和非缓存两种），可增强隐私性。Privoxy 常常作为一个辅助的流量转发模块，工作于操作系统代理接口和 SOCKS5 代理服务接口之间，将本地 HTTP 流量转发到本地或远端 SOCKS5 服务器，从而让 Web 应用可以直接使用 SOCKS5 代理且不需要任何设置，被广泛应用在各种连接国际网络的工具里。\n\rPrivoxy.exe\r 官方的源码是基于 GNU Make 开发环境，上图则是 Porting 到 Windows Visual Studio 开发环境的版本，程序被配置为 Windows 控制台应用程序，添加了 Windows 系统里没有实现的 Linux 函数，源码在这里 privoxy-windows。\n当然，也可以将程序配置为 dll 以方便主程序调用。不过这个程序不会很频繁的被调用，他只处理网络流量和其他程序的代码几乎不会有数据交互，配置为独立进程我觉得更适用。控制台程序可以很容易的隐藏窗口在“后台”运行，下面是一个 C# 启动和关闭 Privoxy 进程的例子。\n// startup try { process_privoxy = Process.Start( new ProcessStartInfo { FileName = PRIVOXY_EXE_PATH, Arguments = CONFIG_PATH, WorkingDirectory = PRIVOXY_EXE_DIRECTORY, UseShellExecute = false, CreateNoWindow = true, }); } catch { ... } // shutdown try { process_privoxy.Kill(); process_privoxy.WaitForExit(); } catch { } process_privoxy.Dispose(); ","permalink":"https://xinlake.dev/blog/2019/10-privoxy-windows/","tags":["Proxy","SOCKS5"],"title":"Privoxy Windows"},{"categories":["Network"],"contents":"I released the XTransmit 0.5.3, the initial version number is 0.5.0, After a small update and some improvements, it is upgraded to 0.5.3. The last number (19142) of the version number is only related to Build, it changes every time Build, there is no other meaning.\n\rXTransmit 0.5.3\r Unzip the downloaded package to any folder (suggest don\u0026rsquo;t include special characters in the path) and execute XTransmit.exe. The software will create two folders binary and datas in the current directory. Under the binary folder is the executable files. Under the datas folder is your data, including the added server, IP address, UA list, site template, configuration, and so on.\nThe software framework can support multiple languages, but currently only English, Chinese is not added. Every language strings have a Key, these keys may change during the development process. If the multi-language is included at the beginning, it will increase the workload when the Key changes. When the language is well organized, there will be multiple languages. My English expression is poor, If you see anything wrong in the software interface you can give me feedback, through GitHub Issues or this article comment. After verification, I will correct it.\nThere will be lots of problems with new software, and although I have done lots of testing, there are definitely some flaws. So welcome feedback.\n","permalink":"https://xinlake.dev/blog/2019/10-xtransmit-0.5.3-en/","tags":["XTransmit","Shadowsocks","cURL"],"title":"XTransmit 0.5.3"},{"categories":["Network"],"contents":"我发布了 XTransmit 0.5.3 版本，版本号初始设置是 0.5.0 经过小幅更新和一些完善即升级到了 0.5.3。版本号的最后一个数字（19142）只和 Build 有关，每次 Build 都会变化，没有其他意义。\n\rXTransmit 0.5.3\r 下载软件包解压缩到任意文件夹（建议路径中不要包含特殊字符），执行 XTransmit.exe 即可。软件运行会在当前目录创建 binary 和 datas 2 个文件夹，binary 里是可执行文件，datas 里是你的数据，包括添加的服务器、IP 地址、UA 列表、站点模板、配置等。\n软件框架可以支持多国语言，不过目前只有英文，中文没有加进去。语言字符串都有 Key，这些 Key 可能会在开发过程中发生变动，如果一开始就包括了多国语言那会增加 Key 变动时的工作量，当语言组织的比较完善时就会有多国语言了。我的英文表达是个大问题，如果看到软件界面有表述不对的地方可以反馈，通过 GitHub Issues 或是本文评论都可以，我核实了都会纠正的。\n刚出的软件肯定会有很多问题，尽管我已经做了不少测试，但肯定还会有一些纰漏。所以，欢迎反馈。\n","permalink":"https://xinlake.dev/blog/2019/10-xtransmit-0.5.3/","tags":["XTransmit","Shadowsocks","cURL"],"title":"XTransmit 0.5.3"},{"categories":["Network"],"contents":"Hugo 生成的站点默认位于站点路径下的 public 文件夹，即 site-path\\public。在站点路径下新建一个用于部署的文件夹，如 site-path\\.deploy，这个文件夹下包含 PowerShell 部署脚本 deploy.ps1 和 Git 仓库 git-repo。hugo server 生成站点后执行 deploy.ps1 即可自动复制新生成的站点文件到仓库并且推送到远端 Git 服务器。\nPowerShell 有一组定义脚本行为的变量，其中 $ErrorActionPreference 告诉 PowerShell 脚本执行出错时（如设定的路径不存在）如何处理，其默认值为 Continue 即显示错误信息然后继续执行。需要将 $ErrorActionPreference 设置为 Stop 即显示错误信息然后停止执行，这样可以避免对文件和仓库造成不必要的改变。Set-Location 是设定工作路径，脚本后续的相对路径都是以工作路径为参考，和脚本文件的存放位置无关。部署脚本的工作路径是仓库路径。\n$ErrorActionPreference = \u0026#34;Stop\u0026#34; Set-Location -Path \u0026#34;site-path\\.deploy\\git-repo\u0026#34; 接下来是执行部署任务：更新站点文件，推送到服务器，清理文件。不过在此之前可以先等待输入提交信息（commit message，默认为当天日期），这样做是可以让部署有挽回的余地，不想部署直接关掉 PowerShell 命令行窗口即可，不会对文件和仓库做任何变动。\n$message_default = Get-Date -Format \u0026#34;yyyy-MM-dd\u0026#34; $message_commit = Read-Host -Prompt \u0026#34;commit message ($message_default)\u0026#34; if (!$message_commit) { $message_commit = $message_default } 然后是更新站点文件，删除原文件再复制新生成的站点文件到仓库。再提交所有变动并推送到远端服务器，git push 会提示输入账号密码（密码不可见）。最后清理生成的站点文件，删除 public 文件夹。下面是完整的 PowerShell 部署脚本 deploy.ps1。\n$ErrorActionPreference = \u0026#34;Stop\u0026#34; Set-Location -Path \u0026#34;site-path\\.deploy\\git-repo\u0026#34; # commit message, defaults to the date of today $message_default = Get-Date -Format \u0026#34;yyyy-MM-dd\u0026#34; $message_commit = Read-Host -Prompt \u0026#34;commit message ($message_default)\u0026#34; if (!$message_commit) { $message_commit = $message_default } # copy newer site files Remove-Item * -Exclude \u0026#34;.git\u0026#34; -Recurse Copy-Item -Path \u0026#34;..\\..\\public\\*\u0026#34; . -Recurse # commit and push git add -A git commit -m $message_commit git push origin master # clean local site files Remove-Item -Path \u0026#34;..\\..\\public\u0026#34; -Recurse 右键点击 deploy.ps1 选择“Run with PowerShell”即可运行脚本执行部署任务。不过，如果你的机器从没运行过 PowerShell 脚本，你可能会看到类似的错误提示“\u0026hellip; xxx.ps1 cannot be loaded because running scripts is disabled on this system. \u0026hellip;”\n这是因为 Windows（客户端版本）的脚本执行策略默认关闭了脚本的执行，以管理员身份在 PowerShell 里将执行策略设置为 RemoteSigned 即可，这个值也是服务器版本 Windows 的默认设置，详细信息可以在这里查看。\nSet-ExecutionPolicy RemoteSigned ","permalink":"https://xinlake.dev/blog/2019/09-hugo-powershell-deploy-script/","tags":["Hugo"],"title":"Hugo PowerShell 部署脚本"},{"categories":["Lifestyle"],"contents":"刚开始建博客时我说“选用了对 Windows 系统更加友好的 Hexo”，今天我换上了 Hugo，因为 Hugo 更加友好。他可以简单的在各种平台下运行，而且对使用者也没有特别要求。不需要关心 Node.js 版本也不需要学习 npm 的使用。\n有人说 Hexo 慢，我觉得还可以接受。反应速度上，执行第一条 Hexo 命令时很慢有时甚至等上 10+ 秒，不过等环境加载好了之后执行命令都还好。运行效率上，基于中间平台运行的 Hexo 比原生的 Hugo 要差很多，但是平时使用不会频繁的执行命令，对效率不会太敏感。相对于很快的框架来说反应慢效率差，但是不影响使用。\n对于我来说，头疼的问题是 Node.js 的更新、Hexo 的更新、还有一大堆插件的更新和依赖关系，不清楚通过何种方式来让 Node.js、Hexo 及相关插件保持在最佳状态。不是说 npm 难懂，仅仅为了使用一个工具而去学习支撑这个工具的平台感觉投入有点大。当然，这是我的主观看法。Hexo 对于 Node.js 开发者那应该是很方便的。\n于是我把 Blog 框架换成了 Hugo，没有头疼的问题还高效。如果你常来我的 Blog 可能会发现一些变化，比如菜单、布局、样式、搜索、博文归档，甚至是 404 页面。。。正如你所见，我已经将 Blog 站点重构。\n","permalink":"https://xinlake.dev/blog/2019/09-blog-v2/","tags":["Hugo","Blog"],"title":"Blog v2"},{"categories":["Lifestyle"],"contents":"说走就走的旅行，说起来容易行动起来可有点难。即便是短短几天，也会有一些难以放下的东西要立刻放下，会有一些必须准备的东西要马上完成，还需要对一些可能的未知的状况有大概的了解，如何应对得要心里有数。拿起包包去看世界，是一件很需要勇气和智慧的事情。\n\r拿起包包看世界\r 以前电视上看到过西湖，那时剧情太动人，西湖太朦胧，以至于除了断桥和雷峰塔就没了多少想象。到了西湖才知道断桥没断，雷峰塔也早已经重建，西湖比想象中的大很多。如果要说第一映像那应该是：优雅、大方、温馨、宁静。\n我们没选在节假日出发，国内的节假日你懂的，尤其是西湖这么流行的地方。只是定了机票简单准备了一下就出发了，到达杭州萧山机场再打车到西湖附近已经是晚上，随便逛了一下就找了个酒店入住，不是节假日得好处之一就是酒店也不用提前预定。第二天起得比较早因为还得去找西湖，不过随口一问就找到了，被人熟知的地方都不难找。\n\r雷峰塔\r 天气偏凉带点微风，很适合看风景。虽然不是节假日但是来西湖的人却不少，这让我们感到有些意外。一眼望去西湖真的大，对岸的人只能隐隐约约的看到。我们没等游览车就开始走了，不知道走到对岸要多久也不知道能不能走完一圈，因为迫不及待也因为不想错过什么。走过断桥、美术馆、咖啡店，感觉走了好久可是对岸还是那么遥远，坐在咖啡店里休息，终于发现其实西湖并没有什么是不可以错过的。长椅、展馆、咖啡店、朋友。。。温馨宁静的氛围以及西湖特有的文化内涵，才是其他地方没有的。\n西湖是个开放景区，很多出入口都可以随时免费进入或离开。景区内几乎没有围栏，没有阻止你行动的障碍物或提示信息，你可以自由游览不受限制，感觉很 Open。西湖的咖啡店不少，从星巴克出来继续走走停停，不到一个小时的时间里就又看到了两三家咖啡店。很多人坐在店里一边看风景一边喝着咖啡聊天讲故事，西湖的韵味加上咖啡的香味那感觉应该会很惬意。到了晚上会亮起很多灯，灯光色调总体偏暖，画面感很不错。\n\r断桥\r \r湖边\r\n雷峰塔离西湖有点距离，从西湖出发去雷峰塔需要打车。那是一座承载了神话故事的古塔，最扣人心弦的情节无人不知晓。传说，白蛇和许仙的跨界姻缘被法海阻拦并意图拆散，为了救许仙，身怀六甲的白蛇与法海在金山寺大战。惊涛骇浪水漫金山，白蛇最终没斗过法海而被镇压在了雷峰塔下。多年以后，白蛇之子许仕林金榜题名，他来到雷峰塔下拜塔救母，雷峰塔倒塌白蛇得以释放，从此白蛇亲人团聚，而法海则成了世人厌恶的对象。\n\r水漫金山\r 故事很精彩，不过真实的雷峰塔并没有压着白蛇，雷峰塔很久以前就倒了，现在的塔是重建的。通往雷峰塔的路程最后有一段不短的台阶，台阶中间建了扶梯可以选择不锻炼身体。塔看上去很普通，但是你不会后悔进入塔内，因为站在塔上的视野很好可以看到整个西湖景区。\n\r雷峰塔上\r 吃饭很方便，景区附近随便的一家的饭馆就可以吃到西湖特有的东西，还可以喝一下西湖的啤酒，当然口味是否接地气就不清楚了。要是来西湖玩最好不要一个人，这的环境氛围不适合一个人冒险。来西湖应该和朋友一起，喝杯咖啡，聊聊感情，留下一段温暖的回忆。\n\r吃饭\r","permalink":"https://xinlake.dev/blog/2019/09-west-lake-impression/","tags":null,"title":"西湖映像"},{"categories":["Android"],"contents":"GMS（Google Mobile Services）为 Android 应用提供了基于云服务的 API，包括广告、游戏、地图、视觉图像、身份验证、电子钱包、App 分析等等很多功能，GMS API 被国际化的 App 广泛使用。GMS 不是 AOSP（Android Open Source Project）的一部分，只存在于通过授权的设备里，如果设备没有 GMS 那么 App 运行时可能会像下面这样。\n\r在没有 GMS 的设备上运行使用了 GMS API 的 App\r 上图左边是一开源 App，它调用了 GMS 的 Vision 功能来扫描二维码（稍后会详细分析）。右边则是一个知名网站（Quora）的 Android 客户端，它在打开时即弹出这样的对话框，估计是调用了 GMS 的身份验证功能。当然，应该有更多的国际化 App 在没有 GMS 的设备上运行会弹出类似的提示，我就不去尝试了。\n接下来看那个开源 App（shadowsocks-android）是如何调用 GMS API 的，我是点击菜单的“Scan QR Code”弹出提示的，追踪代码进入ScannerActivity.kt，在开头处可以看到不少 GMS API 的 import，开源组件 xyz.belvi.mobilevisionbarcodescanner.BarcodeRetriever 也依赖于 GMS 功能。\n... import com.google.android.gms.common.GoogleApiAvailability import com.google.android.gms.samples.vision.barcodereader.BarcodeCapture import com.google.android.gms.samples.vision.barcodereader.BarcodeGraphic import com.google.android.gms.vision.Frame import com.google.android.gms.vision.barcode.Barcode import com.google.android.gms.vision.barcode.BarcodeDetector import xyz.belvi.mobilevisionbarcodescanner.BarcodeRetriever 跳到 OnCreate 处（第 70 行）。这里会调用 GMS 功能创建 QRCode 扫描器，后面打开相机扫码。如果 API 是不可用则会显示一些信息（开头图片）然后进入 fallback（第 62 行），跳转到应用商店的一页面。\nprivate fun fallback() { try { startActivity(Intent(Intent.ACTION_VIEW, Uri.parse( \u0026#34;market://details?id=com.github.sumimakito.awesomeqrsample\u0026#34;))) } catch (_: ActivityNotFoundException) { } finish() } ... override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) detector = BarcodeDetector.Builder(this) .setBarcodeFormats(Barcode.QR_CODE) .build() if (!detector.isOperational) { val availability = GoogleApiAvailability.getInstance() val dialog = availability.getErrorDialog(this, availability.isGooglePlayServicesAvailable(this), REQUEST_GOOGLE_API) if (dialog == null) { Toast.makeText(this, R.string.common_google_play_services_notification_ticker, Toast.LENGTH_SHORT) .show() fallback() } else { dialog.setOnDismissListener { fallback() } dialog.show() } return } ... 逻辑很清晰，就是一 GMS 功能的使用，失败则会提示信息。国内手机很多没有 GMS，包括我手上这台手机也没有，这样就没法支持国际化的 App 正常运行。上面说的跳转到商店页面，国内手机系统都一般都要修改应用商店，不管是网页里打开 Google Play App 还是 App 内跳转都会跳到国内商店页面（系统半年没更新，不知道现在的情况），从而被完全的本土化了。\n对于开源软件有另外一个办法就是把依赖于 GMS 的功能替换为本地模块，就是 App 直接集成相应能力不依赖于云端服务。像这个扫码功能，一般都是 zxing 实现的，集成 zxing 模块修改相应代码即可。而对于广泛的商业流行 App 来说没有 GMS 就比较麻烦，毕竟这些已经是全球应用生态系统的一部分。\n\rApp 集成扫码能力\r","permalink":"https://xinlake.dev/blog/2019/09-unable-to-access-gms/","tags":["GMS"],"title":"无法访问 GMS"},{"categories":["Network"],"contents":"XTransmit is a Windows .NET WPF desktop application, with shadowsocks client, simple curl GUI tool and network speed display panel integrated. XTransmit does not provide shadowsocks services.\n\rXTransmit\r The shadowsocks client features shown below, You can scan the QR code on the screen or manually config to add a SS server, or you can import multiple SS servers from the clipboard or file, and you can delete multiple servers at once. The server list supports server information query and ping delay test. The server name defaults to the remarks of the shadowsocks link, and the information query operation automatically (optional) updates the server name to it\u0026rsquo;s \u0026ldquo;country - region - city\u0026rdquo;. The shadowsocks client currently does not support protocol plugins and global feature settings, only on or off. It is for situations where often connect the public servers.\n\rSS Server List\r \rSS Server Config (The plugin config is not functional)\r\nThe X-CURL is shown below, it is a graphical curl tool. Support for replay, you can set the number of replay counts and the random range of replay delays, each replay it can pick up parameters randomly from the data table (currently only support IP address). This tool manages data by site profiles, which can be used to create profiles for different purposes. Usually, most people should not use this tool.\n\rcURL Site List\r \rcURL Site Profile\r\nThe first picture is the network speed display panel, it just shows the network speed of the selected network adapter. This software packages the binary files of privoxy, ss-local, and curl, and will be extracted to the \u0026ldquo;binary\u0026rdquo; folder under software path at the first run. It verifies the md5 of the files every time startup, if a file does not exist or has changed, it will extract again and overwrite the file. XTransmit will create a notification icon in the taskbar, you can exit the program by clicking \u0026ldquo;Exit\u0026rdquo; in the icon menu or \u0026ldquo;Exit\u0026rdquo; in the upper right menu of the main window.\n\rExit Program\r","permalink":"https://xinlake.dev/blog/2019/08-created-a-small-program-en/","tags":["XTransmit","Shadowsocks","cURL"],"title":"Created a small program"},{"categories":["Network"],"contents":"XTransmit 是一个 Windows .NET WPF 桌面应用程序，集成了 shadowsocks 客户端、简易的 curl GUI 工具、网络速度显示面板。软件不提供 shadowsocks 服务。\n\rXTransmit\r shadowsocks 客户端功能如下图，可以扫描屏幕上的二维码或手动设置来添加一个 SS 服务器，也可以从剪切板、文件批量导入，当然也可以批量删除。服务器列表支持服务器信息查询、ping 延时测试。服务器名称默认为 shadowsocks 链接的 remarks，信息查询操作会将名称自动（可选）更新为服务器的“国家 - 区域 - 城市”。shadowsocks 客户端功能目前没有支持协议插件也没有全局功能设置，只有开或关，适用于经常连接开放公共服务器的情况。\n\rSS 服务器列表\r \rSS 服务器编辑（插件设置无效）\r\nX-CURL 如下图，是一个图形化的 curl 工具。支持重放，可以设置重放次数及重放延时的随机范围，每一次重放都可以从数据库里随机提取参数（目前只支持 ip 地址）。工具以站点模板的方式来管理用户数据，你可以为不同的用途创建模板，使用时打开模板修改参数即可。通常，大部分人应该用不到这个工具。\n\rcURL 站点列表\r \rcURL 站点模板\r\n第一张图是网速显示面板，只是显示选中网络适配器的网速。软件打包了 privoxy、ss-local、curl 的二进制文件，首次运行会释放到软件所在路径 binary 的目录下，每次启动时会校验文件的 md5，如果文件不存在或发生改变则会重新释放并覆盖相应的文件。软件运行会在任务栏创建通知图标，可以点击图标菜单的“Exit”或是主窗口右上角菜单的“Exit”来退出程序。\n\r退出程序\r","permalink":"https://xinlake.dev/blog/2019/08-created-a-small-program/","tags":["XTransmit","Shadowsocks","cURL"],"title":"造了一个小程序"},{"categories":["Android"],"contents":"很多软件的版本号里都有 Build 次数、时间、主机这样的构建信息，这里我介绍一种 Android Studio 里通过 Gradle 脚本自动创建以及更新构建信息的方法，每次构建的时候自动更新版本的 Build 次数、时间、主机等信息，不需要手动设置。\nclass BuildInfo { public int Number public String Time public String Host } 我用上面这个 BuildInfo Class 来描述构建信息，Number 为构建次数，Time 为构建时间，Host 是构建时用的主机。当然，还可以添加其他信息。下面的这个函数执行时会根据机器当前的信息创建、设置并返回一个 BuildInfo 对象。\nBuildInfo updateBuildInfo() { File fileBuildInfo = new File(\u0026#34;${project.projectDir}/build-info.json\u0026#34;) def jsonBuildInfo if (fileBuildInfo.canRead()) { jsonBuildInfo = new groovy.json.JsonSlurper().parseText(fileBuildInfo.text) // Update data to the current information  jsonBuildInfo.Number++ jsonBuildInfo.Time = new Date().format(\u0026#34;yyyy-MM-dd\u0026#34;) jsonBuildInfo.Host = \u0026#34;${System.getProperty(\u0026#34;user.name\u0026#34;)}@${InetAddress.localHost.hostName}\u0026#34; } else { jsonBuildInfo = [ Number: 0, Time : new Date().format(\u0026#34;yyyy-MM-dd\u0026#34;), Host : \u0026#34;${System.getProperty(\u0026#34;user.name\u0026#34;)}@${InetAddress.localHost.hostName}\u0026#34; ] } // Save data to the json file  def jsonString = groovy.json.JsonOutput.toJson(jsonBuildInfo) def jsonBeauty = groovy.json.JsonOutput.prettyPrint(jsonString) fileBuildInfo.write(jsonBeauty) return new BuildInfo( Number: jsonBuildInfo.Number, Time: jsonBuildInfo.Time, Host: jsonBuildInfo.Host ) } 由于 Build 次数 Number 是通过写入文件来记录的，每次 Build 都会在文件里增加计数，所以连同 Time、Host 等信息也都写入到了文件里。这里用的是 JSON 的方式来存取，文件 build-info.json 位于 Module 的当前目录，文件的内容如下。\n{ \u0026#34;Number\u0026#34;: 317, \u0026#34;Time\u0026#34;: \u0026#34;2019-08-22\u0026#34;, \u0026#34;Host\u0026#34;: \u0026#34;User-Name@Host-Name\u0026#34; } 上面代码放到 Module 的 build.gradle 末尾，构建的时候执行 updateBuildInfo 即可返回构建信息 BuildInfo，接下来是将 BuildInfo 设置到软件版本里，代码如下。App 软件 VersionCode 的一般分为四部分：“Major.Minor.Revision.Build”最后一部分常用来表示 Build 信息，这里即表示 Build 次数，VersionName 也做同样的设置。\nandroid { ... defaultConfig { ... BuildInfo buildInfo = updateBuildInfo() resValue \u0026#34;string\u0026#34;, \u0026#34;gradle_build_time\u0026#34;, buildInfo.Time resValue \u0026#34;string\u0026#34;, \u0026#34;gradle_build_host\u0026#34;, buildInfo.Host versionCode(1 \u0026lt;\u0026lt; 24 | 0 \u0026lt;\u0026lt; 18 | 1 \u0026lt;\u0026lt; 12 | buildInfo.Number) // 8bit.6bit.6bit.12bit  versionName \u0026#34;1.0.1-\u0026#34; + buildInfo.Number } } ... class BuildInfo { ... } BuildInfo updateBuildInfo() { ... } resValue \u0026quot;string\u0026quot;, \u0026quot;gradle_build_time\u0026quot;, buildInfo.Time 是通过 Gradle 创建 string 资源（不是在 XML 里创建的），这个资源的 id 是 gradle_build_time value 是 buildInfo.Time 即 Build 的时间，这个资源在 XML 及代码中均可以访问，使用方法也和普通 string 资源一样。版本信息效果如下（没显示全部）。\n\r版本信息\r","permalink":"https://xinlake.dev/blog/2019/08-add-build-infos-for-version/","tags":["Android-Studio"],"title":"给版本添加构建信息"},{"categories":["Network"],"contents":"Shadowsocks（简称为 SS）作为连接国际网络的方式之一，被技术人士使用得比较多。和 VPN 类似，SS 也是基于“中转站”的模式，并且支持非全程加密。相对于 VPN 来说 SS 有较强的技术性，一般使用 VPN 的人可能并未听说过 SS 或者不清楚 SS 是什么，这里我就从偏技术的角度来说一说 Shadowsocks。\nShadowsocks 是一种 SOCKS5 代理，设备的网络数据是通过代理服务器再到达 Web 站点。和前面讲的 VPN 原理一样，如果远端 SS 服务器不受干预设备就能畅通无阻的访问国际网络。加密方式也和 VPN 差不多，Shadowsocks 是非全程加密，从设备到 SS 服务器这一段是加密的，从 SS 服务器到 Web 站点这一段则不处理。\n\rShadowsocks Overview，摘自 Shadowsocks wihte paper\r Shadowsocks 与 SOCKS5 关系 SOCKS 是代理的一种*_（其他的还有 HTTP 代理、SMTP 代理、FTP 代理等等，应用场景不一样）_*，没有专门的应用针对性，通常用于高级的/自定义的网络数据传输。SOCKS 代理协议分 SOCKS4 和 SOCKS5 两版本，SOCKS4 支持 TCP 而 SOCKS5 支持 TCP、UDP 以及基于账号和密码的身份认证，SOCKS5 遵循 RFC1928 协议规范。\nShadowsocks 则基于 SOCKS5 做了一层自定义协议，它定义了数据传输规则、加密/解密方法、协议插件。Shadowsocks 分了 SS-Client 和 SS-Server 两部分来实现自定义规则的数据传输和加密解密，SS-Client 运行于设备端，SS-Server 则运行于服务器端，这两个部分共同完成协议的对接和数据加密/解密。如果客户端需要启用某插件，服务器端则要支持该插件相应的功能，否则插件不起作用。SS-Local 在设备上会表现为一个 SOCKS5 本地代理服务。\n使用代理对网络连接路径的改变，以及导致的速度、延时的变化这些都和前面讲的 VPN 的原理差不多，SOCKS5、Shadowsocks 协议本身不会给网络通信带来太大的开销。代理和 VPN 不同的是有些协议（如 ICMP）不走代理，也没法走代理。而 VPN 对网络通讯的接管就比较全面。此外，数据加解密会引入一些计算，会稍微的提升耗电量。\nShadowsocks 协议的实现 协议只运行于 SS-Local 与 SS-Server 之间，站在应用层的视角看不到协议执行、加解密过程，应用层只需要管理远端服务器连接即可。Shadowsocks 有不同语言的开源实现可用于不同的使用环境，像 Rust 写的 shadowsocks-rust，Go 写的 go-shadowsocks2，C 写的 shadowsocks-libev 等等。其中，shadowsocks-libev 是一种原生实现（依赖 libev 库），在 Windows、Linux、Android 上都可以运行。\n这些实现都会提供服务器端（SS-Server）和设备端（SS-Local）的程序，将 SS-Server 部署到服务器设置好相关的参数，设备端用同样的参数运行 SS-Local 即可实现最基本的连接。设备端的软件就可以通过由 SS-Local 提供的 SOCKS5 本地代理访问国际网络。\n目前开放公用的 SS 服务均不需要登陆，任何一个设备都可以免费连接，而且可以随时切换服务器。即使服务器保留 log 也没法确定设备信息的代表性，不能确定设备的使用人。机器层面的数据和人类实体身份没有任何关联，匿名特性挺好（匿名不代表不支持监管）。\n客户端/应用程序的实现 不是所有的软件都能很好的支持 SOCKS5 代理，很多软件不会主动检测 SOCKS5 代理并使用它。通常 SS 客户端需要架设一个本地 Web Proxy 来支持更为普遍的网络访问，此外还需要和操作系统的代理功能对接，让 Web Proxy、SS-Local 能够直接处理操作系统代理端口的网络流量。这样，像浏览器一类的软件就可以不用任何设置走 SS 提供的线路。\n不过，这对于自带 Web 网络通信能力（不使用操作系统 Web API）也不主动检测系统代理设置的软件（如 git、curl）不起作用，这类软件默认还是走原有的线路。如果需要走代理线路，则直接设置 SOCKS5 代理会比较高效。\n操作系统代理、Web Proxy、SS-Local 都有流量过滤的功能，所以在一些客户端能看到几层过滤设置。最先过滤是操作系统的代理，这里可以设置绕过不需要走代理的流量，这里的过滤也是最高效的因为不需要将数据转到下一级。然后是 Web Proxy 的过滤，有的 Web Proxy 的过滤设计得非常完善和灵活甚至可以支持表达式，在客户端集成了这样的 Web Proxy 后所展示的强大过滤设置即可体现。最后是 SS-Local 的过滤，SS-Local 支持一个过滤列表，太依赖于这一级的过滤往往是低效的因为增加了不必要的本地数据传输。\n客户端 App 的实现在 Android 移动设备上有所不同，在 Android 可以注册一个 VPN 服务来接管网络通讯，可以不用设置系统代理。这会让 SS 客户端 App 看起来很像 VPN，不过这只是使用了 Android 的 VPN 服务接管网络数据，App 实际连接的是 SS 服务器。\n\r这个图标未必都是 VPN 服务\r 服务运营 抛开客户端软件专业的设置不讲，光是连接服务器也会让大部分的 VPN 使用者望而却步，这也是前面讲的“被技术人士使用得比较多”的原因。SS 服务提供方目前很零散，甚至一个开发者既可以在云端搭建 SS 服务，几乎没有公司化的运营方，没点技术背景的人很难用得顺手。这也凸显出 SS 服务方“难以监管”的一面，也许这是比较重要的问题。\n参考资料：\n Shadowsocks white paper https://shadowsocks.org/assets/whitepaper.pdf\nSOCKS Protocol Version 5 https://tools.ietf.org/pdf/rfc1928.pdf\n","permalink":"https://xinlake.dev/blog/2019/08-talk-about-shadowsocks/","tags":["SOCKS5","Shadowsocks","VPN"],"title":"谈谈 Shadowsocks"},{"categories":["Network"],"contents":"在国内，VPN（Virtual Private Network）仍然作为很多人连接国际网路的主要方式。原理上，个人设备是连接到远端 VPN 服务器，通过 VPN 服务器来中转网络访问请求，一般情况下设备到 VPN 的连接不会被干预，所以个人设备可以通过 VPN 来访问国际网络。简单的说，VPN 提供了一条连接到 Web 的新通道，并且可以对通道上的通讯数据进行加密。\n\rRoute Trace\r 上图是同一个设备访问不同网站的路由节点信息，这些节点展示了从设备到站点的网络路径。从图上可以看出，数据从本地网关（192.168.1.1）出去后经过一系列节点最后到达目标站点，信息显示到达不同网站的网络路径是不一样的，左边国内站点（news.163.com）是 9 个节点而右边国际站点（xinlake.github.io）是 14 个节点。路由节点的数量与网站服务器所在区域、网站规模（包括 CDN 铺设）、网路环境都有关系，一般情况下，路径节点少意味着低延时，节点综合负载低意味着高网速（更能接近网路带宽的速度）。没延迟信息的节点（即 Request Timed Out）有可能是真的超时了，也有可能是该节点不响应 ICMP。\n连接 通过 VPN 联网则不会走默认的网络路径，客户端的网络访问会由 VPN 服务器来中转。总的节点数量可能会变多也可能会变少，比如你在国内使用国外 VPN，访问国内站点时网络路径有可能是从国内绕到国外再绕回国内，路径变长；访问国外站点时 VPN 通道及外部网络有可能会使整个路径更加优化，路径变短。同时，VPN 也会使网络延时、速度发生变化。\nVPN 通道有可能绕过干预，从而让设备能够访问一些无法到达的站点，相信这也是国内 VPN 的主要用途。站在 Web 站点的视角看，站点看到的来访者的 IP 地址是 VPN 服务器的 IP 地址，但这并不意味着使用 VPN 后就匿名了，这一点稍后会说明。\n加密 VPN 通道有数据加密的功能，但我不建议将 VPN 的加密功能作为数据通讯的安全保证。因为加密只处理设备到 VPN 这一段的通道，VPN 到 Web 站点这一段不处理。所以说 VPN 并不能保证通讯安全，不能保证 VPN 到 Web 站点这一段的网络通讯不被侦听、拦截、篡改。\nHTTPS 连接具有全程加密的特性，虽然 HTTPS 和 VPN 不是同一类别的东西，但就从提升通讯安全的技术方式来说，HTTPS 比起 VPN 要好。一个网站或多或少都会引用一些第三方提供的服务，这些服务有的不支持 HTTPS 连接，不过现代浏览器在这方面都会有详尽的提示。\n\rHTTPS 完整支持\r 匿名 技术上，VPN 服务器知道一个用户设备的真实 IP 地址，还可以记录这个 IP 的账号登录及网络访问（可以参考一些开源 VPN 的代码）。也就是说，VPN 可以追踪并记录一个用户账号的网络访问。当这个用户账号（机器层面）和使用者（实体身份）有了一定的绑定关系时（如一个人购买了 VPN 服务，支付时需要实体身份信息），使用者的网络访问就很难匿名了。当然，是否记录以及如何使用该记录取决于 VPN 服务商，这有很大的不确定性。\n此外，Web 站点也可以通过技术方法得到真正的来访者信息，比如 WebRTC、Cookie，App（像浏览器、互联网客户端、社交媒体）也可以直接读取本地 IP 地址然后打包上传到服务器。在匿名这个需求上，可以尽量减少机器数据和人类实体身份的关联。\n","permalink":"https://xinlake.dev/blog/2019/07-talk-about-vpn/","tags":["VPN"],"title":"谈谈 VPN"},{"categories":["Lifestyle"],"contents":"这部电影不需多做介绍了，卡梅隆编剧和监制，《阿凡达》级别的特效，相信这些已经有足够的魔力让你去了解去关注这部电影。不管你喜不喜欢科幻，《阿丽塔：战斗天使》都是不容错过的电影巨制，该片绝对会给到你全新的视听感受。\n\r阿丽塔：战斗天使\r 我没看到这部电影的广告宣传，不记得什么时候看到了它的预告片才有了点模糊的印象，知道了有一部叫《阿丽塔：战斗天使》的特效大片将于今年初上映，上映时间还是偶然在影院的海报上看到的。国内上映时间安排在了 22 号，虽然没多少宣传，可还是有很多人买了当天 0 点的票到影院来观看，看来这部电影还是很受关注的。\n片长两个小时多一点点，总体来说相当精彩。影片打斗动作非常酷，特效非常棒。女主阿丽塔是个机械人，由计算机渲染而成的角色。阿丽塔的衣服会随着姿体动作而产生自然的褶皱，头发的晃动符合物理规律，褶皱衣服还有头上发的光线及阴影也都很真实。打斗时，翻滚能够带起地面的尘土，仔细看尘土都能符合物理规律。很精致，很惊人，相信即便是专业人员都很难挑出“骨头”。两个小时，我以为大战要开始了，结果影片结束了，故事没讲完，预示着还有下一部吧。\n\r截图自官方预告片\r 阿丽塔的面部表情也是该片的一大亮点，虽然是机械人，但是她却有着真人般丰富而又细腻的面部表情。实际上，阿丽塔的表情是真实演员演出来的，通过专用设备获取并记录演员的表情数据。在同样的场景里，让阿丽塔呈现同样的表情。喜怒哀乐都能够展现得淋漓尽致，将阿丽塔这一角色刻画得栩栩如生，如同有了人类的灵魂。片中，人类男主爱上机械人女主阿丽塔时，女主说“你会困扰么？我不是完整的人类”，男主说“你是我见过最具人性的人”（大概吧，不记得台词）\n\r预告片中的面部表情\r 影片描绘了一个漂浮在空中的新世界（撒冷），还有被撒冷统治的地面上的工业城。故事围绕女主寻找自己的身份、过去，以及这两个世界的对立所展开。不过镜头始终没有移到撒冷，主角最后的对话中提到“我们哪都不属于，除了拥有彼此”。后面的故事怎么讲，只有电影的创作者们才知道，不管后面的故事怎么讲，都将是让人期待的故事。\n","permalink":"https://xinlake.dev/blog/2019/02-film-impressions/","tags":null,"title":"电影印象《阿丽塔：战斗天使》"},{"categories":["Lifestyle"],"contents":"第一次见到 ZX 时她正踩在凳子上张贴海报，海报比较大，有个同事站在旁边看着会不会贴歪。她同事看着她贴，不停的说“歪了，歪了”、“那边要高一点”，而 ZX 却没有在听，而是用她自己的方法在做，并且反驳说“没歪”、“不会歪”，这让她同事有些不高兴。几分钟后终于贴好了，ZX 说“你看，上下对齐没歪吧”，原来她是找了墙面的水平线作为参照物，上下两端对齐参照物这样就不会贴歪了。\nZX 颜值高稍微化点妆就是个网红，橙色短发、破空牛仔裤，一点不缺时尚小姐姐的特征。到现在，ZX 在麦当劳（兼职，店内大部分服务员都是兼职）工作有近一年的时间。我常在那吃东西，刚开始她和很多新人一样，埋头做事话不多，和大家熟悉之后就放开了，偶尔还有一些小伙伴过来等她下班去玩。是个聪明、活泼、心直口快、偶尔还爆粗口（“他么的，老子又来早了”）的小姐姐。还有些不听话，有时候同事叫她做事情，她就说“我不！”，结果又老老实实跑去做。看得出来，同事都很喜欢她，甚至都被她的“我不！”所传染。\n\r 这的咖啡可以免费续杯，喝完了拿着杯子到点餐处让服务员给你倒即可。我常来，很多服务员都认识我，叫服务员帮我续杯他们也都很乐意。ZX 刚开始不认识我，有一次我对 ZX 说“服务员，可以帮我续杯咖啡吗？”，ZX 马上说“好”，然后拿着杯子转手就递给了一个穿着粉红色工服的小姐姐（YQ），她让 YQ 续杯咖啡，最后由 YQ 将咖啡送到了我的桌子上。我走的时候，对旁边的 ZX 也说了一声“谢谢！”。\n见得多了 ZX 看我也脸熟，咖啡续杯也有了微妙的变化。有一次我拿着杯子去续杯，手不小心碰到了柜台边角杯子差点滑落，这一幕刚好被 ZX 看到，她就“哎呀、哎呀”给我来了一段“幸灾乐祸”般的配音，带着一个自然的微笑，我也笑了笑。YQ 帮我续咖啡一般不耍小机灵，顶多开玩笑说一句“我不！”，不过有一天，YQ 帮我续杯，结果，ZX 端着咖啡送过来，带着自然的微笑。\n","permalink":"https://xinlake.dev/blog/2019/01-the-story-in-2018/","tags":null,"title":"2018 故事，遇见快餐厅的小姐姐"},{"categories":["Computer-Vision"],"contents":"在 Android 手机上合成图片也不麻烦，使用 OpenCV 图像无缝融合功能，通过少量的操作就可以将两副图像无缝的融合到一起，在要求不是很精确的场合，有着可以接受的合成效果。\n\r合成图片\r 上图是在 Android 手机上运行 OpenCV seamlessClone 合成的一张图片，seamlessClone 方法直接调用 Native 的实现。参考 C++ API 文档，我将该方法的声明和参数一起写在下方。\npublic static void seamlessClone(Mat src, Mat dst, Mat mask, Point point, Mat blend, int flags) // Mat src: Input 8-bit 3-channel image. // Mat dst: Input 8-bit 3-channel image. // Mat mask: Input 8-bit 1 or 3-channel image. // Point point: Point in dst image where object is placed. // Mat blend: Output image with the same size and type as dst. // int flags: Cloning method 其中，参与合成的两幅图为 src 和 dst，src 一般比较小它将融合进 dst 成为其一部分。mask 可以用来选取 src 进行融合的区域，可以是 src 的一部分也可以是全部。point 控制 src 的中心点位于 dst 中的位置，即在 dst 哪个位置进行融合。blend 是运算后的输出，它需要和 dst 一样大。flags 告诉 OpenCV 如何融合图像，目前 Android OpenCV 支持两种融合方式 Photo.NORMAL_CLONE 和 Photo.MIXED_CLONE。\n合成封面图的原始图片在下方，分别为 src（普通图片）和 dst（影片《飞鹰艾迪》截图）。创建一个 mask 选择 src 中人物区域融合进 dst，设置 point摆放到右侧的位置即是封面图的效果。封面的融合方式 flag 为 Photo.NORMAL_CLONE，另外一种是 Photo.MIXED_CLONE 稍后将做演示。\n\r图 src，普通图片\r \r图 dst，取自影片：Eddie the Eagle / 飞鹰艾迪，左侧是狼叔\r 在一个 Activity 读取上面两幅图进行融合，并且在布局中显示。布局文件如下，从上到下 4 个 ImageView 分别显示 src，mask，dst，blend\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;ImageView tools:ignore=\u0026#34;ContentDescription\u0026#34; android:id=\u0026#34;@+id/main_imageview_src\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_margin=\u0026#34;2dp\u0026#34; android:scaleType=\u0026#34;fitCenter\u0026#34;/\u0026gt; \u0026lt;ImageView tools:ignore=\u0026#34;ContentDescription\u0026#34; android:id=\u0026#34;@+id/main_imageview_mask\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_margin=\u0026#34;2dp\u0026#34; android:scaleType=\u0026#34;fitCenter\u0026#34; android:visibility=\u0026#34;gone\u0026#34;/\u0026gt; \u0026lt;ImageView tools:ignore=\u0026#34;ContentDescription\u0026#34; android:id=\u0026#34;@+id/main_imageview_dst\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_margin=\u0026#34;2dp\u0026#34; android:scaleType=\u0026#34;fitCenter\u0026#34; /\u0026gt; \u0026lt;ImageView tools:ignore=\u0026#34;ContentDescription\u0026#34; android:id=\u0026#34;@+id/main_imageview_blend\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_margin=\u0026#34;2dp\u0026#34; android:scaleType=\u0026#34;fitCenter\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java 代码，首先是读取原图并设置显示。然后创建 mask 选择人物区域，数据是事先准备好的，当然也可以放到 Android App 里完成，不过这不是本文的重点。结果中的黑白影像就是 mask，区域数据比较粗糙，你会发现人物几个部位会有点模糊。最后创建 blend 调用 Photo.seamlessClone 得到融合输出，结果显示于下面的图中。文中图片均经过一定比例缩小，和代码的数据不能匹配。\nMat matSrc = Imgcodecs.imread(pathImageSrc); Mat matDst = Imgcodecs.imread(pathImageDst); displayMat(matSrc, vImageSrc); displayMat(matDst, vImageDst); Point[] points = { new Point(284, 534), new Point(318, 412), new Point(331, 388), new Point(357, 363), new Point(393, 345), new Point(414, 312), new Point(371, 247), new Point(338, 187), new Point(337, 144), new Point(319, 109), new Point(276, 128), new Point(240, 120), new Point(240, 51), new Point(266, 14), new Point(289, 0), new Point(598, 0), new Point(613, 68), new Point(630, 82), new Point(635, 110), new Point(608, 179), new Point(598, 185), new Point(600, 245), new Point(613, 252), new Point(657, 298), new Point(788, 344), new Point(836, 355), new Point(873, 364), new Point(873, 534), }; Mat matMask = Mat.zeros(matSrc.size(), matSrc.type()); Imgproc.fillConvexPoly(matMask, new MatOfPoint(points), new Scalar(255, 255, 255)); displayMat(matMask, vImageMask); Mat matBlend = Mat.zeros(matDst.size(), matDst.type()); Photo.seamlessClone(matSrc, matDst, matMask, new Point(950, 267)), matBlend, Photo.NORMAL_CLONE); displayMat(matBlend, vImageBlend); \rAndroid Activity\r OpenCV Seamless Clone 可以找到融合方式的说明，下面另外一个融合样例中分别用了两种不同的融合方式。OpenCV seamlessClone 合成会自动处理颜色，使其看上去无缝过渡。可以看出融合后色彩不是很协调，不过可以调整区域颜色来达到更好的效果。\n\rflag: Photo.NORMAL_CLONE\r \rflag: Photo.MIXED_CLONE\r  本文使用开发环境为 Android Studio 3.2.1，OpenCV 4.0.1\n本文代码仅供参考。\n","permalink":"https://xinlake.dev/blog/2018/12-android-opencv-seamless-cloning/","tags":["OpenCV"],"title":"Android OpenCV 图像融合"},{"categories":["Network"],"contents":"账号登录只是 Cookie 的用途之一，事实上这种将匿名访问转为“实名”访问的技术无处不在。当你浏览网页时，服务器可以分配各种账号无关的 Cookie 来收集及追踪网页浏览。不过这个“实名”是客户端，就是说服务器可以知道是什么客户端浏览了什么内容。是机器层面的，不是人的身份。当有多个账号登录网站时，服务器就会分配多个 Cookie，如果这些 Cookie 信息均泄露，那么获得者就可以同时冒用多个账号的身份和网站交互，制造一些有趣的事情。\n\r机器多账号评论\r 前面的几篇博文已经分享过监听网络通讯以及数据包分析方面的内容，Cookie 等信息的获取和数据交互逻辑这里就不再重复了，直接使用 Cookie 信息冒用多账号伪造请求和网站进行数据交互。又是新浪，下一次我尽量不用新浪来实际演示。\n下面的 PowerShell 脚本代码使用 4 个账号的 Cookie 伪造请求对一篇新闻发送评论。同样的，代码中已经删除了一些信息（用“\u0026hellip;”来代替），意在展示原理。和前面的脚本代码有点不同，这里不用 Process 创建进程来运行外部程序，也没有重定向进程的输入输出，而是使用命令行来处理。区别是之前的可以异步，而下面的则是阻塞（流程化处理）。对于异步、多任务、复杂逻辑，编写程序实现好点。\n# Automated comment script for news.sina.com.cn # Updated: 2018.10.20 $header_referer = \u0026#39;\u0026#34;Referer: http://...news.sina.com.cn/comment/skin/default.html?channel=kj\u0026amp;newsid=...\u0026#34;\u0026#39; # 账号的 Cookie 信息，每个元素是一个账号的 Cookie [string[]]$header_cookies = \u0026#39;\u0026#34;Cookie: ... ...\u0026#34;\u0026#39;, ` \u0026#39;\u0026#34;Cookie: ... ...\u0026#34;\u0026#39;, ` \u0026#39;\u0026#34;Cookie: ... ...\u0026#34;\u0026#39;, ` \u0026#39;\u0026#34;Cookie: ... ...\u0026#34;\u0026#39; $post_data_blank = \u0026#39;\u0026#34;channel=kj\u0026amp;newsid= ... \u0026amp;content= ... ... \u0026amp;callback= ...\u0026#34;\u0026#39; $uri_comment = \u0026#34;http://...news.sina.com.cn/cmnt/submit\u0026#34; # Settings $comment_interval = 15 $comment_content = Get-Content -Path ` \u0026#34;...utf8.txt\u0026#34; -Encoding \u0026#34;UTF8\u0026#34; $curl_exe = \u0026#34;...\\Curl\\curl-7.61.1-win64\\bin\\curl.exe\u0026#34; foreach ($comment_line in $comment_content) { $comment_bytes = [System.Text.Encoding]::UTF8.GetBytes($comment_line) $comment_data = [BitConverter]::ToString($comment_bytes).Replace(\u0026#34;-\u0026#34;,\u0026#34;%\u0026#34;) $post_data = $post_data_blank.Replace(\u0026#34;\u0026amp;content=\u0026#34;, \u0026#34;\u0026amp;content=%\u0026#34; + $comment_data) #随机选择账号 $comment_user = Get-Random -Minimum 0 -Maximum ($header_cookies.Count-1) $header_cookie = $header_cookies[$comment_user] # Block cmd /c $curl_exe --silent ... --data $post_data $uri_comment Write-Host `n Start-Sleep -Seconds $comment_interval } Write-Host (\u0026#34;Completed. \u0026#34; + (Get-Date)) foreach 循环每次读取一行评论文本，转换为可发送数据，随机选择一个账号（见临时附加的中文注释）发送评论。从而达到一种“多人接力讲话”的效果。当然，评论的内容、时间等参数也可以有更多的想象。\n这段脚本功能稳定，也可以持续运行很久，但是专业的开发者一眼就能发现问题。那就是频繁的进程创建和销毁（cmd /c），可能会增加内存碎片，导致系统的运行效率下降。\n\r机器多账号评论\r 回到开头提到的“实名”访问，可以说 Cookie 也只是“实名”访问的方案之一，除了 Cookie 之外还有其他的手段来追踪用户（客户端）收集信息。用收集到的用户（客户端）数据，为进一步的生意做准备。例如，当你浏览过或者聊过一些内容后，类似的内容在某一天就会主动的出现。\n且不说这些内容主动出现时，它是让人惊喜的，还是让人反感的。所有“自以为是”的推荐都要基于一个大前提：人与机器是一种绑定关系，机器层面的数据可以用来推理人。然而，这个前提是否完全正确，那是个问号。\n 参考数据：新浪新闻评论（网站、新闻、评论均为“素材”，不代表本人观点）\n参考资料：Cookie https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies\n本文代码仅供参考\n","permalink":"https://xinlake.dev/blog/2018/10-spoof-a-website-by-forging-a-request-4/","tags":["cURL","Cookie","HTTP"],"title":"通过伪造请求来欺骗网站（四）"},{"categories":["Network"],"contents":"网站的有些功能需要登录才能使用（比如发表评论），Web 系统一般用 Cookie 来标识用户（客户端）身份，存储登录状态。当你登录网站后，客户端和服务器传输的数据里就会包含 Cookie 信息，服务器根据 Cookie 来判断你的登录状态。如果这个 Cookie 信息泄露了，那得到 Cookie 信息的人就可以使用你的身份和网站交互（比如发表评论），而且不需要登录，当然也不需要密码。\n前面两篇博文介绍并实际演示了通过程序伪造数据包实现的“机器点赞”，下面也是个实际演示，盗用身份发表评论。欺骗对象还是新浪，不过其他网站也大同小异。\n\r发评论\r User-6773006030 登录了网站，并在一篇新闻文章发了评论“很神秘”（上图）。通过网络监听抓到了发这条评论的 HTTP Post 数据包（下图），红框是数据包的 Cookie 信息。\n\r“发评论”请求\r 和“点赞”差不多，地址比较通用，发送的数据包含各种信息，篮筐是评论内容。下图是“发评论” Post 的服务器回应，回应的数据会包含“发评论”的状态 \u0026lt;script\u0026gt; ... \u0026quot;language\u0026quot;: \u0026quot;ch\u0026quot;, \u0026quot;encoding\u0026quot;: \u0026quot;utf-8\u0026quot;, ... \u0026quot;User-6773006030\u0026quot; ... \u0026quot;time\u0026quot;: \u0026quot;2018-10-17 12:35:48\u0026quot;, \u0026quot;filter_code\u0026quot;: \u0026quot;4000\u0026quot;, ... \u0026lt;/script\u0026gt; （内容较长省略一部分）。\n\r“发评论”回应\r 以上是 User-6773006030 登录了网站之后发评论的流程，HTTP Post 附带 Cookie 发送评论数据，服务器回应“评论”请求状态。而用于标识 User-6773006030 身份的 Cookie 信息是他登录之后才有的（不登录则没有，也没法发评论）。\n如果这个 Cookie 被监听到了（泄露了），信息的获得者就可以用这个 Cookie 伪造评论数据包，以 User-6773006030 的身份发评论。不通过 User-6773006030 已登录的页面，也不用 User-6773006030 授权。使用他的 Cookie 信息，编写脚本直接发送评论。\n# Defaults $string_curl_exe = \u0026#34;...\\curl-7.61.1-win64\\bin\\curl.exe\u0026#34; $string_comment_uri = \u0026#34;http://...news.sina.com.cn/cmnt/submit\u0026#34; $string_header_referer = \u0026#39;\u0026#34;Referer: http://...news.sina.com.cn/comment/skin/default.html?channel=kj\u0026amp;newsid...\u0026#34;\u0026#39; $string_header_cookie = \u0026#39;\u0026#34;Cookie: ... \u0026#34;\u0026#39; # User-6773006030 $string_post_data = \u0026#39;\u0026#34;channel=kj\u0026amp;newsid=...\u0026amp;content...\u0026amp;ie=gbk\u0026amp;oe=gbk... ...\u0026#34;\u0026#39; # Process $process = New-Object System.Diagnostics.Process $process.StartInfo.FileName = \u0026#34;cmd\u0026#34; $process.StartInfo.CreateNoWindow = $true $process.StartInfo.UseShellExecute = $false $process.StartInfo.RedirectStandardInput = $true $process.StartInfo.RedirectStandardOutput = $true $process.Start() $process.BeginOutputReadLine() function postComment() { $process.Refresh() $process.StandardInput.WriteLine($string_curl_exe + \u0026#34; --silent \u0026#34; ` + \u0026#34; --header \u0026#34; + $string_header_referer ` + \u0026#34; --header \u0026#34; + $string_header_cookie ` + \u0026#34; --data \u0026#34; + $comment_post ` + \u0026#34; \u0026#34; + $string_comment_uri) } ... ... 上面的参考代码省略了比较多的内容，意在说明原理。$string_header_cookie = '\u0026quot;Cookie: ... \u0026quot;' 即是 User-6773006030 登录后的 Cookie 信息，服务器收到带有这个 Cookie 的“评论”请求时会认为是 User-6773006030 发的，而实际上是取得这个 Cookie 的人发的。\n此外，新浪新闻的评论内容是转换为“%HEX”的格式发送的，比如 UTF8 编码的“很神秘”会转换为“%E5%BE%88%E7%A5%9E%E7%A7%98”，以下是 PowerShell 中的转化方法，类似 C#。\n# $comment_line 为一行 UTF8 编码的评论内容 # $comment_data 为这行评论的待发送数据，需要赋值给 content $comment_bytes = [System.Text.Encoding]::UTF8.GetBytes($comment_line) $comment_data = [BitConverter]::ToString($comment_bytes).Replace(\u0026#34;-\u0026#34;,\u0026#34;%\u0026#34;) \r机器以 User-6773006030 的身份发评论\r  参考数据：新浪新闻评论（网站、新闻、评论均为“素材”，不代表本人观点）\n参考资料：Cookie https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies\n本文代码仅供参考\n","permalink":"https://xinlake.dev/blog/2018/10-spoof-a-website-by-forging-a-request-3/","tags":["cURL","Cookie","HTTP"],"title":"通过伪造请求来欺骗网站（三）"},{"categories":["Network"],"contents":"上一篇博文实际演示了通过程序伪造请求实现的“机器点赞”，这片博文是另外一个演示，把欺骗对象换成了新浪新闻，伪造的请求也是一条新闻评论的点赞。相对来说，新浪新闻的系统就比较有意思一点。\n先分析一下“点赞”的逻辑，新浪新闻评论点赞只有一次 HTTP Post，没发现 Token 的逻辑。下面两张图是一条新闻评论真人点赞的数据包，第一张图是请求，蓝框内标明了发送的数据，第二张图是服务器回应。\n\r“点赞”请求\r \r“点赞”回应\r 当按下“赞”时，客户端向一个地址 http://....news.sina.com.cn/cmnt/vote 发送 HTTP Post 请求，这个地址看上去比较通用，估计点赞都是这个地址。传输的数据如下，原始数据没有换行，下面的分行显示是方便分析。\n\u0026quot;channel=kj\r\u0026amp;newsid=comos-hmhafir4650580\r\u0026amp;parent=5BC28E6B-6F93DE60-55B9D29A-86F-867\r\u0026amp;format=js\r\u0026amp;vote=1\r\u0026amp;callback=function(a){}\r\u0026amp;domain=sina.com.cn\u0026quot;\r请求的地址比较通用，那么数据就会有比较详细的信息，以下是一些猜测 channel=kj：表示新闻板块，“kj”指科技新闻。 newsid=comos-hmhafir4650580：表示具体新闻。 parent=5BC28E6B-6F93DE60-55B9D29A-86F-867：和评论数据有关。\n服务器回应的数据如下，原始数据也没有换行，这里排成代码的方式是方便分析。服务器回应之后点赞即结束，相对网易新闻来说，新浪新闻点赞的逻辑就简单很多，发个 HTTP Post 就完事。\nvar data={\r\u0026quot;result\u0026quot;: {\r\u0026quot;status\u0026quot;: {\r\u0026quot;msg\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;code\u0026quot;: 0\r}, \u0026quot;language\u0026quot;: \u0026quot;ch\u0026quot;, \u0026quot;encoding\u0026quot;: \u0026quot;gbk\u0026quot;, \u0026quot;content\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;user\u0026quot;: {\r\u0026quot;nick\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;id\u0026quot;: \u0026quot;0\u0026quot;\r}, \u0026quot;time\u0026quot;: \u0026quot;2018-10-14 13:07:29\u0026quot;, \u0026quot;id\u0026quot;: \u0026quot;\u0026quot;\r}\r}\r接下来编写脚本发送这个请求，实现机器“点赞”。这里我用了 Windows 的 PowerShell 脚本和 cURL，PowerShell 可以直接调用 .NET，是 Windows 系统天然的脚本。下面代码我删除了部分内容（用“\u0026hellip;”代替）。\n$comment_url = \u0026#34;http://....news.sina.com.cn/cmnt/vote\u0026#34; $post_data = \u0026#39;\u0026#34;channel=kj\u0026amp;newsid=...\u0026amp;parent=...\u0026amp;format=js\u0026amp;vote=1...\u0026#34;\u0026#39; $header_agent = \u0026#39;\u0026#34;User-Agent: Windows 12; x64; Chrome/72\u0026#34;\u0026#39; $header_refer = \u0026#39;\u0026#34;Referer: http://....news.sina.com.cn/comment/skin/default.html?channel=kj\u0026amp;newsid=...\u0026#34;\u0026#39; $curl_exe = \u0026#34;...\\curl-7.61.1-win64\\bin\\curl.exe\u0026#34; $vote_times = 0 $vote_max = 200 $psi = New-Object System.Diagnostics.ProcessStartInfo $psi.FileName = \u0026#34;cmd\u0026#34; $psi.CreateNoWindow = $true $psi.UseShellExecute = $false $psi.RedirectStandardInput = $true $psi.RedirectStandardOutput = $true $process = New-Object System.Diagnostics.Process $process.StartInfo = $psi $process.Start() $process.BeginOutputReadLine() function requestVote() { $process.Refresh() $process.StandardInput.WriteLine($curl_exe + \u0026#34; --silent --header \u0026#34; + $header_agent + \u0026#34; --header \u0026#34; + $header_refer + \u0026#34; --data \u0026#34; + $post_data + \u0026#34; \u0026#34; + $comment_url) } Register-ObjectEvent -InputObject $process -EventName OutputDataReceived -Action { if($Event.SourceEventArgs.Data.StartsWith(\u0026#34;var data\u0026#34;) -and $Event.SourceEventArgs.Data.EndsWith(\u0026#34;}\u0026#34;)) { $vote_times++ $line_progress = $vote_times.ToString() + \u0026#34;, \u0026#34; + $Event.SourceEventArgs.Data Write-Host $line_progress if ($vote_times -le $vote_max) { Start-Sleep -Seconds 1 requestVote } else { $process.Close() } } } Write-Host `n requestVote 上面的代码是调用 cURL 发送 HTTP Post，收到服务器回应后等 1 秒钟再发送下一次。这样就实现了循环“点赞”，当“点赞”次数超过设定次数时则停止。$header_agent 相关代码仅仅是为了制造一个假象，没有别的作用。\n除了逻辑简单之外，新浪新闻点赞的反作弊策略也比较简单。服务器会判断 HTTP 头的 Referer 信息，数据包需要加入该信息（$header_refer = '\u0026quot;Referer: http://....news.sina.com.cn/comment/skin/default.html?channel=kj\u0026amp;newsid=...\u0026quot;'），否则“点赞”失败，除此外没碰到别的错误。之前提到网易新闻要 60 秒才能点一次，而新浪新闻 1 秒点一次也可以，均为一个 IP。\n\r机器“点赞”中\r \r点赞前\r \r点赞后\r  参考数据：新浪新闻（网站、新闻、评论均为“素材”，不代表本人观点）\n本文代码仅供参考。\n","permalink":"https://xinlake.dev/blog/2018/10-spoof-a-website-by-forging-a-request-2/","tags":["cURL","HTTP"],"title":"通过伪造请求来欺骗网站（二）"},{"categories":["Network"],"contents":"这是个实际演示，通过发送伪造的 HTTP Post 请求来欺骗网站服务器，达到人为的数据异常效果。这里欺骗的对象是一个新闻门户网站，伪造的请求是一条新闻评论的点赞。简单说就是一种机器“点赞”的效果。\n浏览新闻偶然看到了下图的一则评论“八方点赞哪里去了”（第一条评论），既然这位网友需要“赞”，我就分析一下看能不能给他“赞”。在机器点赞之前，新闻的前三条评论点赞数分别为：442，241，183。\n\r网易新闻评论\r 页面上的点赞功能一般都要和服务器发生数据交互，首先监听网络通讯数据包，分析其数据交互逻辑。下图抓到的是真人点第一条评论“顶”的数据包，我过滤了无关的内容。按一下“顶”会有连续 2 次 HTTP Post 请求，以下简称为 POST-1 和 POST-2。\n\rPOST-1 请求\r \rPOST-1 服务器回应\r 上面两张图是 POST-1 的数据包发送及服务器回应。POST-1 向一个地址 http://comment.api.163.com/api/.../DTR1ENL900097U7R/comments/gentoken...（DTR1ENL900097U7R 与新闻的 URI 有关）发送一个 HTTP Post 请求，数据长度为 0。而服务器会回应 {\u0026quot;gentoken\u0026quot;:\u0026quot;6b620b1a-d532-462b-95c2-f2a0be39d0ff\u0026quot;}（蓝框），数据长度是 51 bytes。这个信息在 POST-2 会用到，此外还需要注意一下 Cookie（红色框内），因为两次不一样。\n\rPOST-2 请求\r 完成 POST-1 后紧接着就会发送 POST-2，上图则是 POST-2 发送的数据包，向地址 http://comment.api.163.com/api/.../DTR1ENL900097U7R/comments/299766589/action/upvote...（DTR1ENL900097U7R 与新闻的 URI 有关，299766589 与评论数据有关，upvote 与“顶”或“踩”有关）发送一个 HTTP Post 请求，数据是 ntoken=6b620b1a-d532-462b-95c2-f2a0be39d0ff（蓝框），数据长度是 43 bytes，此外再看看红框内的 Cookie，会多出 WEB_TOKEN=6b620b1a-d532-462b-95c2-f2a0be39d0ff 的信息，这些信息均来自 POST-1。对于 POST-2 服务器会回应“顶”是否成功，没有其他的信息，这一点后面会提到。\n两次 POST 请求后“点赞”动作就完成，总结一下数据交互：页面点击“顶” \u0026mdash;\u0026gt; 发送 POST-1 \u0026mdash;\u0026gt; 服务器返回一个 TOKEN \u0026mdash;\u0026gt; 附带 TOKEN 发送 POST-2 \u0026mdash;\u0026gt; 服务器返回“顶”成功或者失败 \u0026mdash;\u0026gt; 页面“顶”数据变化。从点击到数据变化这一过程一般不会超过 1 秒。\n接下来是编写程序或脚本，构造同样的数据包用同样的逻辑与服务器交互。让服务器认为有个人点击“顶”，从而达到机器“点赞”的效果。从需求上看，浏览器插件、脚本代码、本地（原生）应用程序都可以做到，这里我用了 cURL 来构造数据包与服务器交互。\n@echo off\rfor /f \u0026quot;delims=\u0026quot; %%t in ('curl --silent --data \u0026quot;\u0026quot; \u0026quot;http://comment.api.163.com/api/.../DTR1ENL900097U7R/comments/gentoken...\u0026quot;') do (\rset token_json=%%t\rset token_post=ntoken=%token_json:~13,36%\rset header_cookie=\u0026quot;Cookie:WEB_TOKEN=%token_json:~13,36%\u0026quot;\recho %token_post%\rcurl --silent --header %header_cookie% --data %token_post% \u0026quot;http://comment.api.163.com/api/.../DTR1ENL900097U7R/comments/299766589/action/upvote...\u0026quot;\recho.\r)\r上面代码即是一次“点赞”。curl 发送一个没数据的 POST-1，向服务器请求 Token。用服务器回应的信息生成 Token、Cookie 信息。curl 发送 POST-2，服务器返回“点赞”是否成功。这段代码不能调用太频繁，因为在疯狂的“点赞”过程中我发现服务器返回如下的信息：\nntoken=4ff00b22-6d09-4384-9274-62ee7d2cb9b3\r\u0026quot;\u0026quot;\rntoken=1d57dc34-39de-49ab-aaf9-b7249fac9362\r{\u0026quot;code\u0026quot;:\u0026quot;42900\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;频率超出限制\u0026quot;}\rntoken=0e9031d2-e284-40fb-8fe9-653c68aab242\r{\u0026quot;code\u0026quot;:\u0026quot;42900\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;频率超出限制\u0026quot;}\rntoken=cc5ab02c-06da-469b-84ab-90c91ea5d9be\r{\u0026quot;code\u0026quot;:\u0026quot;42900\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;频率超出限制\u0026quot;}\r第一次返回信息表明请求成功，而后面的都是“频率超出限制”。服务器会判断过于频繁的“点赞”，当间隔调整到 60 秒一次时均成功，即限制（一个 IP）一分钟最多“顶”一次。经过一番机器“点赞”之后，数据已经变成了这样：1568，275，204\n\r网易新闻评论\r  2018-10-27 更新\n目前发现网易新闻评论已经改为登录后才能点赞。本文发布于 2018-10-12，当时点赞不需要登录。   参考数据：网易新闻评论（网站、新闻、评论均为“素材”，不代表本人观点）\n本文代码仅供参考。\n","permalink":"https://xinlake.dev/blog/2018/10-spoof-a-website-by-forging-a-request/","tags":["cURL","Cookie","HTTP"],"title":"通过伪造请求来欺骗网站（一）"},{"categories":["Multimedia"],"contents":"当播放器播放一个视频时你可以在其界面上看到时间跳动，如果调整播放位置（Seek），播放器则会提示调整到的时间。这些时间一般都是用“秒”来计，如果一个视频只有 15 秒、10 秒、或是更短，那么如何 Seek 到 0.2 秒、0.5 秒、或是 1.5 秒的位置观看呢？下面就介绍一种 LibVLC 精细 Seek 的方法，本文内容比较简单。\n\rVLC Seek\r 顺便提一下，Android App 使用 LibVLC 还需要集成 VLC 的 MediaLibrary，因为源码有依赖。本文提到的 MediaPlayer 均指 LibVLC 的媒体播放器 org.videolan.libvlc.MediaPlayer，不是 Android 系统的媒体播放器 android.media.MediaPlayer。\nLibVLC 播放引擎在播放时会主动的报告位置变化、时间变化等信息。MediaPlayer 通过 setEventListener(MediaPlayer.EventListener listener) 方法来设置播放器事件侦听，侦听器（MediaPlayer.EventListener）会接收到播放器事件。LibVLC 已经将播放器事件侦听放到了主线程（UI 线程），首先我们来确认一下，以下代码来自 LibVLC 3.0.13。\nMediaPlayer.java 第 1154 行。设置侦听器实则调用父类（VLCObject）的方法，继续往下跟。\npublic synchronized void setEventListener(EventListener listener) { super.setEventListener(listener); } VLCObject.java 第 100 行。父类实现是直接调 setEventListener(listener, null)，而具体的实现就紧接着下方，这里可以看到会创建一个 Handler 并且绑定到 App 的主线程，源码的注释也写了是运行在主线程。\n/** * Set an event listener. * Events are sent via the android main thread. * * @param listener see {@link VLCEvent.Listener} */ protected synchronized void setEventListener(VLCEvent.Listener\u0026lt;T\u0026gt; listener) { setEventListener(listener, null); } /** * Set an event listener and an executor Handler * @param listener see {@link VLCEvent.Listener} * @param handler Handler in which events are sent. If null, a handler will be created running on the main thread */ protected synchronized void setEventListener(VLCEvent.Listener\u0026lt;T\u0026gt; listener, Handler handler) { if (mHandler != null) mHandler.removeCallbacksAndMessages(null); mEventListener = listener; if (mEventListener == null) mHandler = null; else if (mHandler == null) mHandler = handler != null ? handler : new Handler(Looper.getMainLooper()); } 有兴趣的朋友也继续往下跟，LibVLC 基本是 C 语言开发的，Andrid 版只是加了一层 JNI 以及少量的 Java Wrap。播放引擎事件通知是 C 调用 Java 类中的方法，相关的代码可以参考：libvlcjni.c（第 199 行）、libvlcjni-vlcobject.c（第 190 行）。\n确定了事件侦听在主线程，就可以在侦听器里直接操作 UI 元素，不用做重复的转换主线程的动作，以至于降低 App 的运行效率。接下来分析这个精细 Seek 的需求。\n首先看功能，MediaPlayer 调整播放位置的方法是 setPosition(float pos)，传入的参数是个比例（0.0f 表示开始处，1.0f 表示结尾处），不用转换为“秒”或“毫秒”，只要参数是精细的调整的位置就是精细的，即功能本身是支持的。然后看控制，我们开发播放器一般使用 SeekBar 控件来指示和调整播放进度，这里 SeekBar 按比例转换即可。最后是显示，时间显示需要添加支持 .01 秒，时间变化有两种情况，一个是播放引擎主动发出来的时间变化事件，另一个是用户操作 SeekBar 调整播放进度时的时间提示。\n下方是播放器事件侦听的一部分，MediaPlayer.Event.TimeChanged 事件报告当前播放进度的时间值，单位是 ms（毫秒）。setTime() 则是更新时间显示，这里直接操作 UI 元素。\nprivate final MediaPlayer.EventListener mListenMediaPlayer = new MediaPlayer.EventListener() { @Override public void onEvent(MediaPlayer.Event event) { switch (event.type) { case MediaPlayer.Event.TimeChanged: setTime(TextUtil.formatTime(event.getTimeChanged())); break; //省略部分代码  } } }; 下方是 SeekBar 侦听部分代码，当滑动 SeekBar 时会有个时间提示，告知用户 Seek 到的时间点。\nprivate final SeekBar.OnSeekBarChangeListener mListenSeekBar = new SeekBar.OnSeekBarChangeListener() { @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) { if (!fromUser || mVideoLengthMS \u0026lt; 100) { return; } float position = (float) progress / seekBar.getMax(); String time = TextUtil.formatTime((long) (mVideoLengthMS * position)); setState(time); } //省略部分代码 }; 把时间格式化放到公用静态方法里 String formatTime(long milliseconds)，当小于 2 秒时则按 .2f 格式返回，否则按普通格式返回。\nprivate static final StringBuilder sFormatBuilder = new StringBuilder(); private static final Formatter sFormatter = new Formatter(sFormatBuilder, Locale.getDefault()); public static String formatTime(long milliseconds) { sFormatBuilder.setLength(0); if (milliseconds \u0026lt; 1000 * 2) { return sFormatter.format(\u0026#34;%.2f\u0026#34;, (float) milliseconds / 1000).toString(); } // \u0026gt;= 2 seconds  long seconds = milliseconds / 1000; if (seconds \u0026lt; 3600) { int m = (int) (seconds / 60); int s = (int) (seconds % 60); return sFormatter.format(\u0026#34;%02d:%02d\u0026#34;, m, s).toString(); } else { int h = (int) (seconds / 3600); int m = (int) (seconds % 3600 / 60); int s = (int) (seconds % 60); return sFormatter.format(\u0026#34;%d:%02d:%02d\u0026#34;, h, m, s).toString(); } } 效果图在开头，一个长度为 9 秒视频。播放器暂停于 1.15 秒位置。屏幕中间显示的是用户调整时的时间提示，设置到了 0.65 秒处（松开 SeekBar 才会 setPosotion）。\n","permalink":"https://xinlake.dev/blog/2018/10-vlc-fine-seek/","tags":["VLC"],"title":"VLC 精细 Seek"},{"categories":["Lifestyle"],"contents":"这篇博文来说说《虎胆追凶》这部电影。我不建议你将本文观点作为你是否观影的参考依据，因为每个人的喜好不同，酸甜苦辣都有人爱。\n\r电影海报\r 《虎胆追凶》的主演是布鲁斯.威利斯（以下简称老布）。不像近些年的其他“封面大骗”，海报、封面重要位置使用大牌影星，而影片里大牌影星就露了两脸，戏份不到两分钟。这部电影主要都是老布在演，他不是个打酱油的。老布在影片里是个医生，工作努力家庭和谐，有一天，几个劫匪入室抢劫，混乱之中医生的妻子被杀害，他女儿也受伤住院。影片讲的是一个医生在芝加哥这样一个比较混乱的地方“执法”复仇的故事。\n没有特效，甚至没有激烈的打斗。剧情也很一般，就是追查凶手复仇，不是《飓风营救》那种千里追踪援救女儿。如果没有老布那应该是个很普通的电影，有了老布还是个值得一看的电影。比起那些“封面大片”好很多，不过很难和大制作相比。\n影片中有几个有意思的地方。一个是足球场老布面对面的骂个混混，对话中很自然的把即将说出口的脏话用嘴型（唇语）代替了，骂人无声胜有声音，披着绅士外衣的流氓，他演出来才有那个味。另外一个是老布在家里和家人聊天无意调侃到“我甚至相信过网络”（字幕刷得比较快台词大概是这样），“相信网络”这样的对话、这样的态度，你可以在老布主演的多部影片里看到。\n影片也有没意思的地方。老布演的是个医生，刚开始都不会使用枪械，可是面对危险、面对威胁，这医生看上去太老练了，淡定得像个杀手。我觉得这算是“大爷”级影星的懒吧，到保养期了懒得动。很多影片也是一样的，《敢死队》系列那些老影星也动得少，其第三部更是换成了年轻人去摸爬滚打，《特种部队》系列打斗戏份也都是年轻人。\n","permalink":"https://xinlake.dev/blog/2018/09-film-impressions/","tags":null,"title":"电影印象《虎胆追凶》"},{"categories":["Computer-Vision"],"contents":"你可能已经了解到一些电影特效大片的制作过程，拍摄时演员身旁是纯色屏障和一些道具，穿着奇怪的衣服对着空气拳打脚踢、施展魔法。而到了影片里，演员却出现在惊险的树林，或是跟凶恶的怪兽打斗，画面变得格外精彩。能演电影是幸运的事，借助于现代机器视觉、计算机图形技术，或许你拿起手机也可以拍摄出你的超级大片。\n\r魔兽 Warcraft（2016）\r \r魔兽 Warcraft（2016）电影制作花絮\r\n上图摄像机拍摄到的是蓝屏、道具、草地、穿着奇怪衣服的演员，衣服能够提供肢体的相对位置信息，如何把这样的图像和数据变成电影中画面？\n设想一个三维场景，将拍摄到的图像放到场景中。通过色彩过滤蓝色部分可以替换为任意图像或是场景模型，比如影片中的树林。同样的，大树的位置可以放一颗大树模型。草地添加一些修饰就差不多，如果用模型代替就比较麻烦，因为兽人跑过会带风，风会引起小草晃动还可能带起地上几片落叶，而小草、落叶的运动都得符合物理规律，这样就需要引入物理引擎来模拟模型的运动，会增加大量的制作工作。\n然后是那个兽人，拍摄到的图像里有演员，还有演员肢体的位置信息。同样的，穿着纯色奇怪衣服的演员可以轻松拿掉，而需要在三维场景里换上兽人角色模型。演员的体型没有兽人那么庞大，关键点通过一定的算法将演员映射为兽人，通过肢体关键点绑定可以让兽人的动作和演员的动作保持一致。真人的动作自然而且符合物理规律，不需要添加额外的物理计算，影片中你可以感受到兽人和人类很像。\n将所有的图像帧做类似的处理并且保存就成了一个特效视频，当然，这里说的只是一个大概原理，实际电影特效处理远比这些要复杂而且远不止这些。回到开头提到的“手机拍大片”，类似的原理，得到人物姿态数据然后合成视频。不过姿态数据不通过专业设备获取，而是通过神经网络对图像分析得出。\n\r 上面的演示是读取视频帧（画面也可以取自摄像头），对画面做人物姿态的图像识别。左边是原始视频，右边是姿态识别并标注后的视频，为了对比我把 2 个视频合成了一个演示视频。从图像中检测关键点没法做到专业设备那么精准，也没法做到奇怪的衣服上那么丰富自由的关键点。然而图像分析可以很方便获取到姿态信息，对着摄像头自拍就行。上面的演示你会发现一些错误帧，因为画面质量比较差，人物动作稍快的地方视频图像是模糊的（比如手的挥动，不是所有帧都能看得清手），导致神经网络没法检测到所有关键点。这里用到的神经网络模型能够在一定的遮挡下估计出姿态，但是低质量图像却已经超出了他的设计范围。当然，错误帧可以去掉。\n得到粗糙的姿态数据后就可以做进一步的合成，可以像电影一样构造一个虚拟场景，构造一个虚拟人物模型跟着真人跳舞。下面的演示中（左边是原始视频，右边则是合成视频），简单的贴了一张巴黎的场景图片，导入姿态数据设置一个位置渲染模型（这里的模型仅仅是贴了一个头像还有简单的连线），同步合成的视频（右边）即是“模型”按照人物的动作跳舞。\n\r 稍微复杂一点，如果把模型放到另外一个视频里，看起来即就有点电影的效果。下面的演示也类似（左边是原始视频，右边则是合成视频），简单截取了一段游戏过程（Diablo 3 武僧跳舞）视频，导入做真人动作的模型，然后合成新视频。左右 2 个视频都在动，但是右边的“小女孩”做的动作和原始视频真人的动作是一致的。\n\r 如果愿意做大工程，则可以使用图形引擎构造一个虚拟世界，导入三维模型角色，绑定人物的动作，让虚拟角色在虚拟世界里做真人的动作。也可以做精细的图像分割，将人物从视频中取出来，放到其他视频或是虚拟场景里。用手机拍摄你的大片。\n参考：\n OpenPose https://github.com/CMU-Perceptual-Computing-Lab/openpose\nOpenCV https://github.com/opencv/opencv\n","permalink":"https://xinlake.dev/blog/2018/08-human-pose/","tags":["OpenCV"],"title":"人物姿态识别与画面合成"},{"categories":["Computer-Vision"],"contents":"目标检测（Object Detection，检测识别图像中的物体，下称图像识别）神经网络之一 YOLO 已经发布了第三版（YOLOv3），他名称挺有意思：You Only Look Once，你只看一次。他的作者也挺有意思，Darknet 项目的 LICENSE.fuck 看上去有着一种随意、不讲究的个性。随着神经网络技术的兴起，机器视觉软件库之一 OpenCV 在其 3.3 版本中正式添加了 DNN 模块，以支持神经网络算法应用。他能够支持多种机器学习（包括深度学习）框架的预训练神经网络模型，对图像、视频应用神经网络算法。\n在 Android 运行图像识别的方案之一是使用 OpenCV 导入 YOLO 预训练模型，对图像执行目标检测。相比与机器学习框架而言，OpenCV 对视觉、图像处理提供更加广泛的支持，DNN 模块能够支持多种机器学习框架的神经网络模型，此外也支持移动设备。使用机器学习框架设计、训练、优化神经网络，使用机器视觉软件库来应用神经网络算法，也是不错的方案。\n\rYOLO 自带 Demo，图片来自 YOLO 官网\r 你可能见过上面的图片，这是在 PC 上运行 Darknet 框架加载 YOLO 预训练模型对一张图片进行检测的结果。YOLO 作者提供了 COCO 数据集和 VOC 数据集的预训练模型下载，还有一个支持 9000 种物体检测的模型不过有段时间没有维护。使用 COCO 数据集预训练模型能识别（COCO 数据集范围内的）80 种物体，而使用 VOC 数据集预训练模型能识别（VOC 数据集范围内的）20 种物体。\nYOLOv3 的改进提升了速度和精度，输出数据也有点变化，已发布的 OpenCV 3.4.1 已不能兼容 YOLOv3，不过最新的代码已经修复兼容性问题。如果要使用 OpenCV 运行 YOLOv3 神经网络模型的话，需要下载最新的 OpenCV 代码并编译库文件，新的版本号已经是 4.0 开头。此外，如果想让 OpenCV 支持 Nvidia 图形硬件 CUDA 计算加速的话，需要安装 CUDA Toolkit，编译时间会长很多。\n\r \r \r\n上面的几张图你应该没见过，这是在 Android 手机上运行 YOLO 的效果，使用 OpenCV 导入 YOLO 对摄像头画面做图像识别。在都没有 OpenCL 计算加速的情况下，Android（835 CPU）手机的速度比 Windows 10 笔记本（i7 低电压版）快些。最后的视频不是 YOLO 而是 MobileNet 的效果，MobileNet 数量少速度快拿来演示流畅些，效果都差不多，当然也可以做更深入的应用。\n\r 参考：\n COCO DataSet http://cocodataset.org/\nYOLOv3 Paper https://pjreddie.com/media/files/papers/YOLOv3.pdf\nDarknet https://pjreddie.com/darknet/\nOpenCV https://github.com/opencv/opencv\n","permalink":"https://xinlake.dev/blog/2018/05-yolo-android/","tags":["OpenCV"],"title":"在 Android 上运行图像识别"},{"categories":["Lifestyle"],"contents":"科幻电影中的 AI 和现实生活中软件的 AI 是两码事了。电影中的 AI 是让机器具备了人类的特性，有本能，有意识，有情感，能思考，能学习成长，能自我创造出机器的世界。而现实生活中的 AI 软件，很多是机器学习（Machine Learning，后面会提到）的技术应用，让一些功能更加智能，让一些算法得以实现，让一些设想得以落地应用，但是软件本质没有变化，即固有的（人工编写的）程序逻辑和数据结构。\n2001 年的一部科幻大片《人工智能》（Artificial Intelligence）再一次的将智能机器搬上了大银幕，相比于早年的《霹雳五号》、《终结者》该片更加强调了智能机器的人类特性，相信很多人看过之后都会对 AI 有更深刻的认知。2008 年开始的《钢铁侠》系列以及后续的漫威超级英雄电影：《美国队长》系列、《复仇者联盟》系列，出现的 AI 则实现得更加具体。如贾维斯的机器视觉、语音交互能力，奥创的自主意识。2014 年《机器纪元》吧 AI 机器刻画得更加深刻，也揭示了 AI 的威胁性。2017 年的《异形：契约》电影则更多的强调了 AI 的潜在威胁。\n《异形：契约》影片中片头的有个细节，机器人能给自己取名大卫，弹钢琴他可以自己选择曲目，有自己的喜好，即 AI 具有自我意识。不过大卫没有恶意不会伤害任何人，没有任何危险但却藏有着巨大的威胁，因为你不知道 AI 会自我进化成什么样，AI 机器的自我成长与改变受各种未知因素影响，不可预测不可控制，影片后期揭示了 AI 机器造成的毁灭性破坏。\n有点讽刺意味的是片中展示机器人大卫的画作，和现今 AI 工具软件通过机器学习（Machine Learning，后面会提到）生成的一些图像风格颇有几分神似。让人不得不注意 AI 技术的潜在的威胁性，不得不感叹普通大众对现实生活中的 AI 技术了解不够，也不得不承认技术厂商对 AI 的定义与公众对 AI 的认知存在偏差。\n\r异形：契约 / Alien：Covenant / 2017\r 计算机 AI（Artificial Intelligence）科学的目标是创造像人类一样的智能机器，就像科幻电影中刻画的 AI 一样。然而创造这样的机器会涉及到广泛而深入的科学技术，有些特性实现了如语音识别，有些特性是实现了一部分如语义、机器视觉，有些还处于理论探索阶段如知识图谱，有些还是科学难题如意识、情感等等。如果要创造一个像大卫一样的智能机器，现有的科技是远远达不到的。\n机器学习（Machine Learning）是对未知数据进行预测的一种方法，该科学使用大量数据进行统计、分析，让机器获得某方面数据的预测判断能力。例如输入 1000 张猫的图片训练，然后随机拍摄一只猫，机器即能够判断照片是否有猫。这里的“学习”不是像人类一样的自我变化与成长的过程，而是通过数学建模和工具软件创建一个面向应用的图片内容预测算法。如果要判断图片是否有猪，则需要用猪图片来训练。神经网络（Neural Network）是一种机器学习的算法，模仿生物大脑神经网络，在机器视觉、语义方面都有不少应用。\n开发者可以引入机器学习框架或是支持神经网络算法的程序库，设计出带有 AI 技术应用的软件，使其具备一定的数据智能预测和处理能力，例如下面的带有图像识别能力的 Android 相机应用。一些 AI 技术应用往往带来亮眼、惊艳的效果，不过本质还是属于软件的功能特性，只是这个功能特性用到了 AI 领域里的一些技术。这个 AI 不是电影里那个有意识会思考的 AI。\n\rAndroid AI 图像识别\r","permalink":"https://xinlake.dev/blog/2018/05-ai-in-movies-and-in-life/","tags":null,"title":"电影中的 AI 和生活中的 AI"},{"categories":["Computer-Vision"],"contents":"人脸检测很早就有了，以前的数码相机拍照的时候就能实时检测出人脸、笑脸。不过那时的检测会有一些要求，脸要摆正，最好不能带帽子，笑要露出牙齿会更容易检测到。现在随着深度学习技术的发展，人脸检测技术也有了巨大的变化。\n\rHi, I am Iron Man\r 下面这个视频演示的是较早的人脸检测技术，使用 OpenCV 级联分类器（Cascade Classifier）的人脸目标检测，OpenCV Object Detection。类似的特征检测技术也有 Dlib 目标检测，Dlib Object Detector、Dlib face 68 landmarks。视频中，当脸完全出现在画面中时软件能检测到，而我用手挡住脸时软件就没法检测到。这里为了不露脸，当软件检测到人脸时是在对应位置贴了“钢铁侠”，而不是画个框。“嗨，我是钢铁侠”，当然这只是个玩笑。\n\r 机器视觉软件库完善支持深度神经网络后（DNN），人脸检测几乎突破了检测，计算量大但是效果也不一般。OpenPose（Real-time multi-person keypoint detection library）是使用深度学习技术做图像检测的开源项目之一，支持身体姿势、面部、手势的关键点检测识别，也有 Caffe 实现的神经网络模型。OpenCV DNN 模块可以使用 OpenPose 的模型做识别，官方的例子比较新（大概创建于 10 天前）目前没有面部关键点检测部分，可以参考OpenPose 文档编写相关代码来使用这个功能。\n接着上面挡住部分脸时的检测，下图是 OpenCV 使用 OpenPose 神经网络模型面部关键点检测的结果。每个点都有意义（官方文档），最多 70 个点连接起来就是一张特定的脸，图中这几个点是遮挡后检测出的一部分关键点。\n\r图片，面部检测\r 也有用手遮挡和带眼镜的，如下 2 张都是视频截图（电脑硬件一般跑神经网络计算帧率低，用视频演示时间较长就截图了）。基于神经网络的人脸识别比起图像目标检测要智能很多，即便遮挡一部分也能检测出人脸。这些图中你会发现关键点输出结果有明星偏差，笔记本摄像头画质很差，而且检测时我对图像做了较大的缩放（硬件计算能力有限），检测结果自然达不到画面本身的精度。\n\r视频，面部检测\r \r视频，面部检测\r 从图像中检测到人脸并不困难，有遮挡仍然可以准确判断。判断 2 张人脸图像相似度来做面部身份验证也不难，能够支持数量不大情况下（如机场、公司）的身份验证应用。\n然而从千万人脸图像中准确辨认出任意一个人的身份，调取他的身份信息，就不是那么容易。神经网络的人脸检测为面部识别提供了方案，可以将面部图像作为数据集来训练网络模型，做进一步的面部识别身份验证；或许也可以使用特征点设计算法描述每张人脸独一无二的特性，来搭建通用的面部身份信息数据库，或是在已有的身份数据库中添加高效的面部特征检索支持。\n\rRoboCop（机械警察）2014，面部身份数据库\r 相关博文可点击 OpenCV 标签，以下是一些参考资料\n OpenPose https://github.com/CMU-Perceptual-Computing-Lab/openpose\nLFW Data Set http://vis-www.cs.umass.edu/lfw/\nOpenCV https://opencv.org/\nDlib http://dlib.net/\n","permalink":"https://xinlake.dev/blog/2018/03-face-detection/","tags":["OpenCV"],"title":"人脸检测与面部识别"},{"categories":["Computer-Vision"],"contents":"跑分第一的手机未必能跑得动神经网络，因为 CPU 的浮点计算能力很有限，在执行图像处理、机器视觉等一些计算密集型任务时，效率会非常低。处理那样的任务是 GPU 的专长，图形硬件不仅能 3D 绘图渲染，还能通过 OpenCL 等接口使用它的计算能力。这里将展示 PC 平台上图形硬件对神经网络的计算加速，在 OpenCV DNN 图像检测程序中对比 CPU 和 GPU 计算的效能差别。\n\rcpu computing\r 在 Windows 10 上创建 VC++ 应用程序，程序打开摄像头运行 OpenCV DNN 对摄像头画面做图像检测。使用的是 Darknet 预训练的 YOLO 模型，模型约 194M 支持 80 种物体的识别，上图即是图像检测的截图，用的是 CPU 计算。\n下图是使用 CPU 计算时的情况，帧率大约 0.2-0.5 之间，CPU 占用 50%-80% 之间，没有占用 GPU，Memory 约占 850M。\n\rCPU 计算，资源占用\r 然后是通过 OpenCL 把计算交给 GPU 去完成，OpenCV DNN 调用 setPreferableTarget(DNN_TARGET_OPENCL)，代码说明如下。编译执行，计算任务已经转到 GPU 上，程序对 CPU 的占用只有几个点。\n/** * @brief Enum of target devices for computations. */ enum Target { DNN_TARGET_CPU, DNN_TARGET_OPENCL }; /** * @brief Ask network to make computations on specific target device. * @param[in] targetId target identifier. * @see Target */ CV_WRAP void setPreferableTarget(int targetId); 下图是使用 GPU 计算时的情况，帧率大约 1.6-2.5 之间，CPU 占用一般少于 5%，GPU 占用 70%-95%，Memory 约占 1438M。\n\rGPU 计算，资源占用\r 图形硬件是 i7-4600U（笔记本低电压版）自带的 HD Graphics 4400，驱动支持 OpenCL 1.2。系统是 Windows 10 x64，开发环境是 Visual Studio 2015 Community，VC++ Application 和 OpenCV Library 都是 x64。下面还有个简单的效能对比列表，作者的图形驱动没有更新，程序处理也有可优化之处。\n\r硬件信息\r    YOLO计算 帧率 CPU占用 GPU占用 内存占用     CPU 0.2-0.5 50%-80% 0 850M   GPU 1.6-2.5 \u0026lt;5% 70%-95% 1438M    数据仅供参考！以下是一些参考资料\n YOLO https://arxiv.org/abs/1612.08242\nDarknet https://pjreddie.com/darknet/yolo/\nIEEE 754 https://en.wikipedia.org/wiki/IEEE_754\nOpenCL https://www.khronos.org/opencl/\n","permalink":"https://xinlake.dev/blog/2018/03-opencv-dnn-opencl/","tags":["OpenCV"],"title":"OpenCV DNN with GPU Computing"},{"categories":["Computer-Vision"],"contents":"这篇博文也是介绍 OpenCV DNN 模块在 Android 上的应用，运行 GoogLeNet 模型对摄像头画面做图像分类。相关的博文点击文章左下方的 OpenCV 标签可以看到。下图底部有一行字 coffee mug（咖啡杯），这是对画面中的这杯咖啡准确识别分类的结果。\n\r图像分类\r 本文不涉及深度学习和神经网络的理论，相关的参考资料会在文章末尾处列出。文中的所有代码仅供参考\n下载 GoogLeNet 模型文件：bvlc_googlenet.prototxt，bvlc_googlenet.caffemodel，classes_ILSVRC2012.txt。创建 Android App 引入 OpenCV AAR，模型文件（51M）可以放到 assets 里打包进 APK。参考 OpenCV DNN 使用 GoogLeNet 图像分类，把 C++ 代码翻译成 Java。\n读取类别名称文件，处理字符串。把 classes_ILSVRC2012.txt（UTF-8 编码）文件的数据分行截断，生成 String 数组。\nprivate String[] readClasses(String file) { AssetManager assetManager = getAssets(); try { // Read data from assets.  BufferedInputStream inputStream = new BufferedInputStream(assetManager.open(file)); byte[] data = new byte[inputStream.available()]; inputStream.read(data); inputStream.close(); String synset = new String(data, \u0026#34;utf-8\u0026#34;); return synset.split(\u0026#34;\\n\u0026#34;); } catch (Exception e) { Log.e(\u0026#34;knight\u0026#34;, \u0026#34;read classes error\u0026#34;); } return null; } \rread classes\r 摄像头画面帧的处理，摄像头画面帧不在 UI 线程程里，显示结果部分设置 TextView 要放到 UI 线程。\n@Override public Mat onCameraFrame(CameraBridgeViewBase.CvCameraViewFrame inputFrame) { // Get a new frame  Mat frame = inputFrame.rgba(); Imgproc.cvtColor(frame, frame, Imgproc.COLOR_RGBA2RGB); // GoogLeNet accepts only 224x224 BGR-images  Mat inputBlob = Dnn.blobFromImage(frame, 1.0f, new Size(224, 224), new Scalar(104, 117, 123), true, false); mNetwork.setInput(inputBlob, \u0026#34;data\u0026#34;); //set the network input  Mat prob = mNetwork.forward(\u0026#34;prob\u0026#34;); //compute output  Mat probMat = prob.reshape(1, 1); //reshape the blob to 1x1000 matrix  Core.MinMaxLocResult result = Core.minMaxLoc(probMat); // display result  final String objects = mClassNames[(int) result.maxLoc.x]; runOnUiThread(new Runnable() { @Override public void run() { vText.setText(objects); } }); return frame; } 下面是个演示视频，摄像头移到咖啡附件即已经认出这是一杯咖啡。帧率较低和 MobileNetSSD 差不多。\n\r 参考资料\n GoogLeNet https://arxiv.org/abs/1409.4842\nCaffe https://caffe.berkeleyvision.org/\nOpenCV DNN https://github.com/opencv/opencv/tree/master/samples/dnn\n","permalink":"https://xinlake.dev/blog/2018/03-android-opencv-dnn-googlenet/","tags":["OpenCV"],"title":"Running GoogLeNet on Android device"},{"categories":["Computer-Vision"],"contents":"这标题都是英文，看了一下专业词汇多还真不好写中文。本文的内容是介绍 OpenCV DNN（Deep Neural Networks）模块在 Android 上的使用，运行深度学习模型来做图像的多目标识别。移动设备上基于深度学习的图像识别技术离实际应用还有段距离，不过该技术却有着惊艳的效果。\n\r目标检测\r 计算机视觉开源软件库 OpenCV 刚升级到了 3.4.1，新版本除了集成了一些补丁和问题修复外，JNI 库也整理得更好了，此外还发现新增了一个使用 Android Camera2 接口的 CameraView （org.opencv.android.JavaCamera2View.java）。但是我在手机上用这个 View 发现画面的色彩不对，想尝鲜的朋友可以调试一下。启用 Camera2 接口应该可以在 Android 上更好的适配硬件加速，将视觉处理大量的浮点计算交给 GPU 去做。\n在 Android 手机上（Snapdragon 835 CPU）调用 OpenCV 可以看到以下 logcat 信息，接下来可以参考 OpenCV DNN Toturial 在 App 上使用 DNN。\nGeneral configuration for OpenCV 3.4.1 ===================================== Version control: 3.4.1 Platform: Timestamp: 2018-02-23T12:15:01Z Host: Linux 4.13.0-32-generic x86_64 Target: Linux 1 aarch64 CMake: 2.8.12.2 CMake generator: Ninja CMake build tool: /usr/bin/ninja Configuration: Release CPU/HW features: Baseline: NEON requested: NEON FP16 required: NEON disabled: VFPV3 C/C++: ... 此处内容太多已省略 OpenCV modules: To be built: calib3d core dnn features2d flann highgui imgcodecs imgproc java java_bindings_generator ml objdetect photo python_bindings_generator shape stitching superres video videoio videostab Disabled: js world Disabled by dependency: - Unavailable: cudaarithm cudabgsegm cudacodec cudafeatures2d cudafilters cudaimgproc cudalegacy cudaobjdetect cudaoptflow cudastereo cudawarping cudev python2 python3 ts viz Applications: android_examples Documentation: NO Non-free algorithms: NO Android: Android ABI: arm64-v8a STL type: gnustl_static Native API level: android-21 SDK target: android-21 Android NDK: /opt/android/android-ndk-r10e (toolchain: aarch64-linux-android-4.9) android tool: /opt/android/android-sdk-java7/tools/android (Android SDK Tools, revision 25.2.2.) ... 后面已省略 OpenCV DNN 模块可以读取多种深度学习框架的网络模型，生成 DNN 的网络对象（DNN 不支持模型训练）。模型文件放到 assets 打包进 APK，运行时复制（一次）到 App 目录后 DNN 就可以读取。Java API 的注释少，这里是打开 C++ API 来看看读取 Caffe 模型的说明。\n\r读取模型\r /** @brief Reads a network model stored in \u0026lt;a href=\u0026#34;http://caffe.berkeleyvision.org\u0026#34;\u0026gt;Caffe\u0026lt;/a\u0026gt; framework\u0026#39;s format. * @param prototxt path to the .prototxt file with text description of the network architecture. * @param caffeModel path to the .caffemodel file with learned network. * @returns Net object. */ CV_EXPORTS_W Net readNetFromCaffe(const String \u0026amp;prototxt, const String \u0026amp;caffeModel = String()); 在摄像头图像帧里运行模型计算输出，标注识别结果。可以参考官方 Toturial，3.4.1 版本需要做一点小修改，代码如下。\n@Override public Mat onCameraFrame(CameraBridgeViewBase.CvCameraViewFrame inputFrame) { // Get a new frame  Mat frame = inputFrame.rgba(); Imgproc.cvtColor(frame, frame, Imgproc.COLOR_RGBA2RGB); // Forward image through network.  Mat blob = Dnn.blobFromImage(frame, IN_SCALE_FACTOR, new Size(IN_WIDTH, IN_HEIGHT), new Scalar(MEAN_VAL, MEAN_VAL, MEAN_VAL), false, false); mNet.setInput(blob); Mat detections = mNet.forward(); ... } 下面有个演示视频，手机摄像头现实场景的图像识别，输出结果的标注代码稍微改了一下，看起来更加明显一点。MobileNetSSD 模型的物体较少大概 20 个，所以有些目标识别可能会不对，但这不是问题换个模型就可以。\n\r 参考资料\n MobileNet https://arxiv.org/abs/1704.04861\nCaffe https://caffe.berkeleyvision.org/\nOpenCV DNN https://github.com/opencv/opencv/tree/master/samples/dnn\n","permalink":"https://xinlake.dev/blog/2018/03-opencv-dnn-objects-detection/","tags":["OpenCV"],"title":"Android OpenCV DNN Objects Detection"},{"categories":["Lifestyle"],"contents":"最重要的节日，最热闹的节日。最普通的人，最平常的方式。看看传统之外的过年，这里有不一样的春节。\n\rHHappy new year 2018\r 年三十，到处都挂起了节日的灯笼。有人回了老家，有人去了旅行，而附近的广场上依然可以看到不少年轻人，其中一部分是社区自愿者（常参与或举办公益活动）。这几天天气都很好，志愿者们办起了拔河活动，吸引了附近的人来玩，制造热闹的气氛。\n\r广场拔河\r 下午五六点，估计很多人的老家已经开始了年夜饭，不过这里很多人的年夜饭可能只是快餐，像肯德基、必胜客那样的餐厅在春节也营业。下图那家餐厅装修不错，很难想象这样的餐厅会接待乞丐，可这却是真的。我曾经有 2 次看到他们接待乞丐（乞丐吃东西付钱），而且还对乞丐提供额外的帮助。节假日常有年轻人来这吃东西，过年也不例外，也有人在这里吃东西聊天。\n\r会接待乞丐的餐厅\r 晚上是个特别的时间，而对于晚上去哪里浪，他们也早已有了计划。来到世界之窗，人不比往常少，其他公园估计也差不多，也许这就是浪的方案之一。园内的节目会持续到跨年的时刻，饿了的话还可以买东西吃，有汉堡也有泡面。不过这些都不重要，关键是他们过了一个自己的新年。\n\r公园\r \r天空都被点亮了\r","permalink":"https://xinlake.dev/blog/2018/02-a-different-spring-festival/","tags":null,"title":"不一样的春节"},{"categories":["Android"],"contents":"Android 手机刷机主要分两步，先刷入 Recovery 程序然后可以刷一个你喜欢的 Android ROM。有些手机锁定了 BootLoader，这类手机要先解锁才能刷 Recovery。小米手机 6 的 Bootloader 也是锁了的，参考解锁流程解锁后才能刷机。\n对于 Android 手机，系统和不可卸载 App 占一个分区叫 system，用户数据（如照片、视频、联系人）和可卸载 App 占一个分区叫 userdata。system 和 userdata 加起来就接近（因为还有一些小分区）存储内存的大小，刷机会把新 ROM 写入 system 区，还要对 userdata 区做擦除操作，所以刷机前先要做好数据备份。提醒，刷机有风险！ 如果你没有听说过 BootLoader、FastBoot、Recovery，那我建议你不要自己刷机。\n小米手机 6 使用已有段时间，对于这款手机我印象最深刻的是：大部分 App 无法卸载。所以对手机系统做了一次手术，解决 App 卸载问题。解锁 BootLoader 及备份数据后，下载软件就可以对手机进行刷机手术了。这里，Recovery 用的是开源程序 TWRP，XDA 上可以下载到开源的 ROM。\n手机 USB 连上 PC，打开调试模式，adb reboot bootloader 重启手机。待手机进入 FastBoot 后，fastboot flash recovery twrp-3.2.1-0-sagit.img 刷入 Recovery（twrp-3.2.1-0-sagit.img）程序。完成后 fastboot reboot 重启手机同时按住：音量加、电源，进入 Recovery 模式。\n\r刷 Recovery\r 进入 Recovery 模式后，使用 TWRP 刷入新的 ROM 并且擦除数据，完成后正常重启即进入新系统。这里我图省事刷入了官方开发版 ROM（因为该版本可以打开 root 功能，有 root 自然就可以把内置 App 卸载掉），没有多尝试第三方 ROM，相信有一些优秀的第三方开放 ROM。\n刷入开发版 ROM 后打开 root 功能，就可以开始以 root 身份卸载 App 了。例如“天气” App，在 Settings 里查看其包名为 com.miui.weather2，执行 pm uninstall --user 0 com.miui.weather2 即可卸载。下图左是卸载前，右是卸载后。\n\r卸载 App\r 就这样可以把内置 App 卸载掉，但是有些 App 卸载了对系统有影响，详细情况见下面的 BAT 批处理程序，执行即批量卸载。一些小工具就没管了，像“指南针”、“计算器”如果要卸载也可以把包名加进去。\n 批量卸载脚本，供参考  goto start\r[Packages cause setting problems after uninstalled]\rcom.android.thememanager\rcom.miui.cloudservice\r[Packages cause startup problems after uninstalled]\rcom.android.quicksearchbox\rcom.xiaomi.finddevice\r:start\radb root\radb shell pm uninstall --user 0 com.wali.live\radb shell pm uninstall --user 0 com.xiangkan.android\radb shell pm uninstall --user 0 com.mi.liveassistant\radb shell pm uninstall --user 0 com.xiaomi.mimobile.noti\radb shell pm uninstall --user 0 com.xiaomi.jr\radb shell pm uninstall --user 0 com.sohu.inputmethod.sogou.xiaomi\radb shell pm uninstall --user 0 com.android.midrive\radb shell pm uninstall --user 0 com.xiaomi.scanner\radb shell pm uninstall --user 0 com.xiaomi.midrop\radb shell pm uninstall --user 0 com.xiaomi.gamecenter\radb shell pm uninstall --user 0 com.xiaomi.vipaccount\radb shell pm uninstall --user 0 com.xiaomi.account\radb shell pm uninstall --user 0 com.mipay.wallet\radb shell pm uninstall --user 0 com.miui.yellowpage\radb shell pm uninstall --user 0 com.miui.player\radb shell pm uninstall --user 0 com.miui.tsmclient\radb shell pm uninstall --user 0 com.miui.video\radb shell pm uninstall --user 0 com.miui.virtualsim\radb shell pm uninstall --user 0 com.miui.bugreport\radb shell pm uninstall --user 0 com.miui.weather2\radb shell pm uninstall --user 0 com.miui.personalassistant\radb shell pm uninstall --user 0 com.miui.voiceassist\radb shell pm uninstall --user 0 com.miui.notes\radb shell pm uninstall --user 0 com.android.email\radb shell pm uninstall --user 0 com.android.browser\radb shell pm uninstall --user 0 com.android.calendar\radb shell pm uninstall --user 0 com.android.providers.downloads.ui\rpause\r最后附几张卸载了大部分内置 App 后的效果图（用的是 Microsoft Launcher，可以使用 Bing 每日壁纸），第一张桌面，后面两张是所有 App（在“抽屉”里）。终于拒绝了小米的全家桶。\n\r拒绝全家桶\r","permalink":"https://xinlake.dev/blog/2018/02-sagit-new-experience/","tags":["TWRP"],"title":"小米 6 刷机，卸载全家桶"},{"categories":["Android"],"contents":"Android Studio 3 发布有段时间了，之前看到的是测试版就一直用着 2.2.3 没更新。前段时间项目模块升级，Android Studio 的更新提示已经是 3.0.1 正式版了，于是就对开发环境也做了一次升级。本文说几点 Android Studio 3.0.1 的几点变化，不是全面介绍 Android Studio 3 的新特性，而是一些项目迁移过程中感受到的 Android Studio 3.0.1 相对于 Android Studio 2.2.3 的几点变化。\n\rAndroid Studio 3.0.1\r 自带 OpenJDK Android Studio 3.0.1 已经自带了 JDK，不需要安装 JDK 即可以正常运行。adb 程序也可以独立运行（不需要打开 Android Studio，不需要安装 JDK）。安装 Android Studio 后只需要下载必要的 sdk 即可。\n\rAndroid Studio 3.0.1 自带 JDK\r 打开 \u0026ldquo;Project Structure\u0026rdquo; 选项可以看到 JDK 相关的设置，这里可以看到 \u0026ldquo;Use embedded JDK(recommended)\u0026rdquo; 即“使用内置的 JDK（推荐）”默认处于勾选状态，并且下方有 jre 的路径（Android Studio 位于 D:\\AndroiDev\\android-studio）。再到 D:\\AndroiDev\\android-studio\\jre 下查看 java 版本，显示 OpenJDK\n\rJDK 默认设置\r 快速文档 按 Ctrl+Q 即会弹出鼠标所选内容的技术文档，该功能在 Android Studio 2.2.3 时加载文档很慢，看一个 Method 的文档等上几十秒都有可能。StackOverFlow 上有人找到了原因并给出了解决方法（快速文档功能首先会尝试打开在线内容，没有在线内容再使用本地，有些区域无法连接在线文档，即导致文档加载慢的问题，修改 jdk.table.xml 指向本地文档可解决）。这一问题在 Android Studio 3.0.1 里已经不存在了，SDK 里安装 \u0026ldquo;Documentation for Android SDK\u0026rdquo; 看文档 Ctrl+Q 秒开。\n\r离线文档\r 模块依赖 你可能已经发现，Android Studio 3.0.1 项目模块的 build.gradle 里 dependencies 配置已经从旧版的 \u0026ldquo;compile\u0026rdquo; 变成了 \u0026ldquo;implementation\u0026rdquo;。\n比如：compile fileTree(dir: 'libs', include: ['*.jar'])\n变为：implementation fileTree(dir: 'libs', include: ['*.jar'])\n对于这样的变化，gradle 官方文档有解释，章节 49.2 提到 \u0026ldquo;compile\u0026rdquo; 配置目前存在但不应当再使用，应当使用 \u0026ldquo;api\u0026rdquo; 或 \u0026ldquo;implementation\u0026rdquo;，还说明了两者的区别。官方原文：java_library_separation\n The plugin exposes two configurations that can be used to declare dependencies: api and implementation. The api configuration should be used to declare dependencies which are exported by the library API, whereas the implementation configuration should be used to declare dependencies which are internal to the component.\n  （翻译）插件公开了两种可用于声明依赖项的配置: \u0026ldquo;api\u0026rdquo; 和 \u0026ldquo;implementation\u0026rdquo;。\u0026ldquo;api\u0026rdquo; 配置应当用于声明由库 API 导出的依赖项, 而 \u0026ldquo;implementation\u0026rdquo; 配置应当用于声明组件内部的依赖项。\n  Note: The compile configuration still exists but should not be used as it will not offer the guarantees that the api and implementation configurations provide.\n  （翻译）注意：\u0026ldquo;compile\u0026rdquo; 配置仍然存在，但不应使用，因为它不会提供的 \u0026ldquo;api\u0026rdquo; 和 \u0026ldquo;implementation\u0026rdquo; 配置所提供保障。\n 就是说，如果不想让依赖项暴露给外部（让外部不可调用）则使用 implementation，估计这个配置适用大部分情况。如果模块的依赖项目需要给外部使用则用 \u0026ldquo;api\u0026rdquo;。\n","permalink":"https://xinlake.dev/blog/2017/12-android-studio-3-changes/","tags":["Android-Studio"],"title":"Android Studio 3 几点变化"},{"categories":["Lifestyle"],"contents":"今天不说代码，说说电影。有科幻的也讲故事的，有卖座的也票房一般的，说说一些电影印象。\nEnchanted / 魔法奇缘 / 2007 我是在电视上看到这部电影，该片讲的是一个纯真的公主穿越到现代遇见王子的故事。\n什么是约会。初中英文老师就讲过 Date 也有 约会 的意思，不知道你下课后有没有忘掉。这部电影中有个对白，当问到什么是 Date 时，公主用一句话很简单的解释了 \u0026ldquo;Date\u0026rdquo;\n We go out to dinner, And we talk about ourselves, Our likes and our dislikes. Our interests.\n我们出去吃饭，聊聊我们自己，喜欢什么，不喜欢什么，我们的兴趣爱好。\n 体会得到的咫尺天涯。一个优雅的舞会上有着忧郁的两个人，不同世界的公主和王子终于走到了一起，却又不能在一起。此时片中安排了一部缓慢的插曲，这个插曲的名字是 So Close，插曲的结尾告诉你什么是咫尺天涯。\n So close. So close. And still so far.\n这么近。这么近。却还是那么远\n Transformers 1-3 / 变形金刚 1-3 / 2007-2011 起初我以为这部电影是拍给青少年看的，后来听说不错就网上看了第一部，确实震撼。从 2007 到 2011 先后上映了前三部，后面又计划了风格变化较大的后三部，前段时间上映了《变形金刚 5》，按照计划还会有《变形金刚 6》。这个系列的出色的特效是他的标签之一，然而后面的 4、5 可能是缺少物理引擎的使用，细心的朋友应该能看到不少破绽，不过总体来说他的特效是不错的。\nOST（原声音轨）同样出色。OST 很多时候作为背景音乐出现，有时根据场景播放一小段，有时被配音、对话掩盖，你可能注意不到，但是 OST 也是需要精心创作的。偶然听到变形金刚 OST 中的几个完整音乐，和他的画面一样，出彩。下面的几首，很不错。\n Arrival to Earth\nAutobots\nNest\nBattle\nOur Final Hope\n Iron Man 1-2 / 钢铁侠 1-2 / 2008-2010 早在第一部结尾（放完演员表之后，离场早了看不到）就有彩蛋，那独眼龙想要钢铁侠加入《复仇者联盟》，然后《复仇者联盟》及《美国队长》都出现了钢铁侠。钢铁侠 1、2 很多科技上的内容都讲的比较合理（第 3 部那火人反派感觉就变味了），虽然有些是技术上无法实现的，但是不玩一半计算机一半神仙。钢铁侠系列电影还有后面提到的几部电影其特效都很棒，但是随着技术进步，特效慢慢的成了大众化标配，给人留下印象的可能是那些创新的东西。\n创新的人机交互、机器视觉。这个系列的电影很多场景都是创新的人机交互，语音、手势、三维内容显示，这可能也是未来 UI 的发展趋势。片中还有不少片段都演示了计算机视觉技术的应用，只是目前科技还没到那水准。\n\r机器视觉导航及运动计算\r Oblivion / 遗落战境 / 2013 这是一部比较特别的科幻，该片的编剧肯定很有才华。反转的剧情，巧妙的情节编排，把一个简单的故事讲的此起起伏又不凌乱，绝对是让人印象深刻的科幻电影。虽然该片演员阵容单薄还有一些场景不合理，但是在他的亮点面前，似乎都都可以忽略。下面一段是美式的隐居山林，对白位于湖边小木屋处。\n\r湖边小木屋\r  You know what you said to me once？\nYou szid when it was all over, you would build me a house on a lake.\nWe would grow old and fat together.\nAnd we would fight.\nMaybe drink too much.\nAnd then we would die and be buried in a meadow by the lake.\nAnd the world would forget about us.\nBut we would always have each other.\n  还记得当初对我说过的话吗？\n等一切结束了在湖边为我造一座房子\n我们一起变老一起变胖\n我们还会争吵\n会喝很多酒\n还说等我们死后，就葬在湖边的那片草地上\n世界会忘记我们两个\n但我们永远拥有彼此\n Interstellar / 星际穿越 / 2014 时空、引力、黑洞、宇宙。。。这部电影把这些几乎无法认知的奥秘般到了大银幕。电影中涉及到科学内容都很认真的处理力求真实，该片还专门请了科学家做一些理论研究，此外还有一部 50 分钟的视频（片名：The Science of Interstellar）详细的讲述了电影中的科学。看完这部电影相信很多人对相对论会有更深刻的理解。\n时光倒流只能是幻想。时间是相对的，可以拉长可以压缩但是不能回转，唯一能在时间维度中移动的是引力。黑洞巨大的引力造成时空扭曲，跑到黑洞旁边的星球玩一下，地球上可能就已经过了好几十年。等回到地球时，发现已经穿越到了别人的未来，一切都是那么自然。\n\r黑洞的样子\r Mad Max: Fury Road / 疯狂麦克斯：狂暴之路 / 2015 阳光烈日，沙漠绿洲，血腥战车，尘土飞扬。如果要用一句话形容该片的话，那就是爽快疯狂重口味。片中的场景是沙漠中的一个绿洲，一个恶心的大王控制了资源，影片讲的是主角逃离这个肮脏小王国的故事。童话般的名字（不死老乔、汽油镇、子弹农场），纯粹的恶人，超夸张的改装车，不用太多思考上来就开干，影片虚构了一个大人的童话世界。\n片尾的一句话。影片的结尾将大银幕交给了一句话，让人感觉疯狂与重口的童话背后也有着深刻的内涵。\n\r片尾\r  我们是该去什么地方\u0026hellip;\n还是要在这片荒芜之地寻求更好的自己？\n史上第一人\n Fast And Furious 7-8 / 速度与激情 7-8 / 2015-2017 除了飙车砸车之外，也有战坦克、拉飞机、汽车跳伞、撞潜艇，还有爆笑全场的对骂。这个系列的特效内容一直不缺新鲜的血液。此外他还有创新的科技想法，而且还是有连贯性的。2015 年上映的《速度与激情 7》里展示了基于机器视觉的查找定位及跟踪的“天眼”系统，2017 年上映的《速度与激情 8》则出现了反跟踪的技术手段。其实这些都是实实在在可实现的科技，当然需要一定的资源才能去做这些事情。\n科幻展现了人们对科技的期待，也表达对科技的担忧。\n\r天眼查找跟踪\r \r被入侵的自动驾驶\r\n","permalink":"https://xinlake.dev/blog/2017/09-film-impressions/","tags":null,"title":"电影印象 2007-2017"},{"categories":["Android"],"contents":"findViewById 是 Android UI 设计里经常调用的一个方法，根据传入的 id 查找并返回对应的 view 对象。那么 Android 是如何去 find 一个 view 的呢，本文结合官方源码分析 findViewById 的原理。以下源码均来自 Android 7.1.1 （API 25） SDK。\nfindViewById 的实现 如果从一个 Activity 里调用 findViewById，则会跳到 Activity 的方法，代码如下（Activity.java 第 2322 行）\n/** * Finds a view that was identified by the id attribute from the XML that * was processed in {@link #onCreate}. * * @return The view if found or null otherwise. */ @Nullable public View findViewById(@IdRes int id) { return getWindow().findViewById(id); } 代码很简单，直接跳到 Window 部分，代码如下（Window.java 第 1261 行）\n/** * Finds a view that was identified by the id attribute from the XML that * was processed in {@link android.app.Activity#onCreate}. This will * implicitly call {@link #getDecorView} for you, with all of the * associated side-effects. * * @return The view if found or null otherwise. */ @Nullable public View findViewById(@IdRes int id) { return getDecorView().findViewById(id); } 然后跳到 View 部分。**如果是从一个 View / ViewGroup findViewById 则是直接从此处开始。**代码如下（View.java 第 19366 行）\n/** * Look for a child view with the given id. If this view has the given * id, return this view. * * @param id The id to search for. * @return The view that has the given id in the hierarchy or null */ @Nullable public final View findViewById(@IdRes int id) { if (id \u0026lt; 0) { return null; } return findViewTraversal(id); } 调用 findViewTraversal 来查找，但是此处对于 View 及 ViewGroup（继承于 View） 却有着不同的实现。\n 对于 View 比如 ImageView，判断 id 匹配则返回自己，否则返回 null。代码如下（View.java 第 19326 行）  /** * {@hide} * @param id the id of the view to be found * @return the view of the specified id, null if cannot be found */ protected View findViewTraversal(@IdRes int id) { if (id == mID) { return this; } return null; }  对于 ViewGroup 比如 LinearLayout，在他的子 View 里遍历查找 id 匹配的 View 并返回它。代码如下（ViewGroup.java 第 3942 行）  /** * {@hide} */ @Override protected View findViewTraversal(@IdRes int id) { if (id == mID) { return this; } final View[] where = mChildren; final int len = mChildrenCount; for (int i = 0; i \u0026lt; len; i++) { View v = where[i]; if ((v.mPrivateFlags \u0026amp; PFLAG_IS_ROOT_NAMESPACE) == 0) { v = v.findViewById(id); if (v != null) { return v; } } } return null; } 上面 ViewGroup 的 findViewTraversal 代码可以得知 \u0026ldquo;find\u0026rdquo; 一个 View 的方法是简单的遍历。如果子 View 也是 ViewGroup 例如一个 LinearLayout 里有一个 LinearLayout，则会在 v.findViewById(id) 调用到子 ViewGroup 的 findViewTraversal 完成一个递归遍历查找的过程。下面的代码是简单的效率测试，布局中只有一个 ImageView，数据源于主流 CPU 手机的运行结果\nlong begin = System.nanoTime(); ImageView imageView = (ImageView) findViewById(R.id.main_imageview); long time = System.nanoTime() - begin; // time 的值为： 27055，30365，36562，33750，45902... 约为 20-50 微秒之间 在 Android 8.0（API 26） 中的变化 如果使用 Android 8.0 SDK 编译旧程序你可能会发现一条类似的提示：Casting \u0026lsquo;findViewById(R.id.main_imageview)\u0026rsquo; to \u0026lsquo;ImageView\u0026rsquo; is redundant 说类型转换是多余的，因为 API 26 已经将 findViewById 改成了这样\npublic \u0026lt;T extends View\u0026gt; T findViewById(int id) 所以编译的 SDK 版本更新到 26 后，即 compileSdkVersion 26，完全可以吧 findViewById 前面的类型转换去除掉。\n","permalink":"https://xinlake.dev/blog/2017/08-findviewbyid/","tags":["ViewGroup"],"title":"findViewById 的效率"},{"categories":["Multimedia"],"contents":"1. 有趣的 在一个项目工作中偶然接触到 UPnP（Universal Plug and Play），一个基于本地网络的即插即用设备互联协议标准，后来经了解发现 UPnP 是个很有趣的东西。这篇博客分享一些 UPnP 的知识及介绍在 Android 应用中使用 UPnP（资料 UPnP Device Architecture 2.0）。\n1.1 特性   对等，没有主次\n所有 UPnP 网络中的设备即可以提供服务，也可以主动发起数据传输，设备的角色取决于软件（不像USB协议那样的主从模式）。如果一个设备实现了 AVTransport 那么它可以提供媒体渲染服务，例如一台智能电视；如果一个设备实现了 ContentDirectory 那么它可以提供媒体浏览和流媒体传输服务，例如开启媒体流的功能的 PC；如果设备是使用 ControlPoint 那么它就像是个智能遥控器，例如安装一些 DLNA 控制软件的手机；一台设备可以支持多个服务同时还可以有控制功能，例如 Windows Media Player 它即可以提供媒体内容服务，也可以播放推送来的媒体，还可以把媒体推送到其他设备上播放。UPnP 网络中的设备没有一个 Master，所有设备都是对等。\n  即插即用，零配置\n这个即插即用不是硬件层面的（不像 USB 那样的串行总线设备拓展），而是通过本地网络实现。设备可以动态加入网络（通过 SDDP 发现设备），传达其功能（使用 XML 描述），并了解其他设备的存在和功能。设备可以顺利自动地离开网络，而不会留下任何不必要的状态。这些都可以不需要用户配置，设备处于同一个网络下就可以通过 UPnP 直接互动。\n  1.2 关于安全性与路由器的 UPnP 功能 广泛使用的路由器 UPnP 端口映射功能用的是 Internet Gateway Device（简称 IGD），是 UPnP 定义的设备之一，提供端口映射功能（NAT 穿越），让本地网络的设备端口映射到外网。这样软件就能使用 IGD 绕过 NAT 进行数据传输，映射之后外部网络就能很轻松的直接访问内网设备，他安全性取决于使用者对软件的信任。下图是路由器开启 UPnP IGD 功能后被其他设备发现，软件能够直接使用它的（端口映射）功能，不需要用户配置。\n\r路由器 IGD 设备\r UPnP 设备互动一般没有身份验证，比如家用智能电视机任何设备都可以控制，但是本地网络的 UPnP 应用都是可预测可控制的。虽然 ControlPoint 能够推送外网上的视频给电视机，但是就和打开电脑浏览器看电影差不多和开不开 IGD 没关系。\n2. 媒体分享与无线显示的区别 UPnP 本身包含了一组网络协议如 TCP、UDP、HTTP、XML，而 DLNA（Digital Living Network Alliance）则是包含了更多协议的标准，下图 DLNA 的技术架构里面列出了对 UPnP 的使用（资料 DLNA Guidelines）。\n\rDLNA 技术架构\r DLNA/UPnP 的内容很多是无线媒体分享娱乐方面，和无线显示技术 Miracast 作用很像但是又有着本质的区别\n2.1 硬件支持  DLNA/UPnP：基于网络的设备互联，不需要硬件、操作系统支持，软件就可以实现。 Miracast：需要操作系统支持（Android 4.2 以上、Windows 8.1 以上），还需要 Wi-Fi 硬件模块支持。  2.2 连接对象  DLNA/UPnP：软件上的服务和控制点，一个服务允许多个设备访问，一个控制点也可以处理多个服务。一个设备可以同时实现多个服务，服务和控制点连接没有绑定。比如推送的一个电影到电视上播放，电影有可能在手机上、电脑上、电视机本身、还可以是一个外网视频，而电视剧同时还能支持其他设备的内容访问及播放控制。 Miracast：点对点（Peer to Peer），是设备连接扩展一个无线显示屏幕。如果一个屏幕需要被其他设备连接使用，则首先要解除原有的连接。  2.3 媒体传输，编解码  DLNA/UPnP：Play To（推送），当用户推送一个电影到播放器（如电视机，DLNA 渲染设备，简称 DMR）时候是向 DMR 发送了电影的 URL，DMR 收到这个 URL 推送时就播放这个电影，数据传输是在 DMS （DLNA 媒体服务器，简称 DMS）和 DMR 之间。 Miracast：Cast（屏幕投射），它是将屏幕内容、声音编码为特定媒体格式，通过媒体流传输到接收端，接收端再解码呈现。 过程：DLNA/UPnP，屏幕 —\u0026gt; 编码 —\u0026gt; 接收端解码。接收端只需支持固定解码。Miracast，DMS 媒体源 —\u0026gt; DMR 解码。DMR 需要支持全格式解码。  2.4 功能对比，应用场合  DLNA/UPnP：没有涉及到屏幕内容传输，Android 5.0 以上可以通过 MediaProjection 取得屏幕数据，编码，推送到 DMR，这样也可以以软件的方式实现屏幕传输，但是效率不会有底层支持模式下的 Miracast 高，另外像远程屏幕点击的功能也不好实现。DLNA 的方式更适用于无线媒体分享娱乐。 Miracast：本身支持在无线屏幕上显示不一样的内容，默认显示主屏镜像，但是 Miracast 没法支持远程控制，比如控制屏幕扬声器的音量。如果通过 Miracast 看高清电影会多一个转码过程，其效率没有 DLNA 高，而且 1080p 以上的高质量媒体源很难保持原始质量。Miracast 的方式更适用于多屏幕内容展现互动。  3. Android 应用使用 DLNA/UPnP 在发布 UPnP 协议规范的网站上（Open Connectivity）列出了一些开源的 UPnP SDK，Cling 就是其中一款，它是 java 实现的可以在 Android 上使用。cling 主要分两部分：cling core，由 java 实现的 UPnP Device Architecture 1.0；cling support，Media Server、Media Renderer 的一些拓展还有路由器 IGD API，使用 cling 可以实现大部分的 DLNA/UPnP 功能应用。\n3.1 使用 cling 库 导入库 cling 依赖的库不少，该项目源码是通过 maven 在线构建的方式编译，也可以将依赖库下载到本地通过 Android Studio（gradle）直接构建。这个是 cling 2.1.1 的完整依赖库（供参考）\ncling-core-2.1.1.jar，cling-support-2.1.1.jar，\rseamless-http-1.1.1.jar，seamless-util-1.1.1.jar，seamless-xml-1.1.1.jar\rjetty-client-8.1.21.v20160908.jar，jetty-continuation-8.1.21.v20160908.jar，\rjetty-http-8.1.21.v20160908.jar，jetty-io-8.1.21.v20160908.jar，\rjetty-security-8.1.21.v20160908.jar，jetty-server-8.1.21.v20160908.jar，\rjetty-servlet-8.1.21.v20160908.jar，jetty-util-8.1.21.v20160908.jar，\rservlet-api-3.0.jar\rjavax.enterprise-cdi-api-1.2.jar，javax.mail-mail-1.4.7.jar\rnet.sf.kxml-kxml2-2.3.0.jar\rorg.dbunit-dbunit-2.2.3.jar\rorg.hibernate-hibernate-core-3.6.10.Final.jar\rorg.slf4j-slf4j-api-1.6.6.jar，org.slf4j-slf4j-jdk14-1.6.6.jar\r创建设备，实现服务 如果设备提供功能，能让其他设备看到，则需要创建 LocalDevice。\nnew LocalDevice( new DeviceIdentity(new UDN(\u0026#34;1111\u0026#34;)), new UDADeviceType(\u0026#34;MediaRenderer\u0026#34;), new DeviceDetails(\u0026#34;My MediaRenderer\u0026#34;), new LocalService[]{ createAVTransportService(), createRenderingControlService() });  DeviceIdentity：设备的 UDN，即 UPnP 网络中唯一的设备标识符需要唯一，程序可以读取机器的一些特征 ID 来生成 UDN。 UDADeviceType：设备类型，比如媒体渲染器是 “MediaRenderer”，媒体服务器是 “MediaServer”。 DeviceDetails：设备的名称，制造商，型号等信息。这些信息一般是对用户可见的，可以参考 android.os.Build 生成默认信息，然后用户可以设置。 LocalService：设备提供的服务，这里就是 UPnP 设备服务功能的入口，要根据上面的 UDADeviceType 实现不同的服务，如这里的 DMR 按照规范需要实现的 AVTransport。cling 库封装好的各种设备服务的抽象类，继承服务抽象类，实现功能即可。  注册表，事件侦听，控制点 UPnP 的控制能操控网络中的各种服务，cling 的 API 功能主要封装在那个 AndroidUpnpService 里。\n Registry（不是操作系统的注册表）是通过 AndroidUpnpService.getRegistry() 得到 UPnP 服务的 Registry，这里有 UPnP 网络中的本地及远程设备列表，也是在这里添加删除本地服务，另外在这里设置 UPnP 事件侦听。 RegistryListener 事件侦听器里有设备上线、下线、更新等消息。 ControlPoint 通过 AndroidUpnpService.getControlPoint() 得到，通过 ControlPoint 就可以搜索设备，可以执行各种使用服务的操作。  4. 媒体流传输 如果应用需要能够分享本地媒体，让 UPnP 网络上的其他设备能浏览，或是能够主动推送本地媒体到一个远程 DMR 播放。那么这个应用需要实现 HTTP/RTP 媒体流传输功能，还要创建 DMS 设备。媒体流服务一般用 HTTP，因为 HTTP 媒体流传输是 DLNA 规范要求支持，而其他方式媒体流传输是 Optional。\n下图左边是 Android 推送一个本地视频到 Windows 10 Media Player，播放显示的媒体信息来源来自于 192.168.1.101:9000 即 Android 提供的流媒体服务（URL 地址资源路径经过编码）。\n\r媒体推送\r 4.1 一些 HTTP Server 库的信息   Apache HttpComponents Apache 开发的，很专业，需求匹配基本上就可以选用了。早期版本的 Android 集成了该库后面没有集成了（参考信息 Apache HttpClient for Android），如果现在使用该库可能会遇到兼容性问题，如 Android Studio 提示过期的 API（deprecated），编译会提示缺少 class 之类的信息。\n  NanoHTTPD\n引用官方的说法：Java 实现的一个小型的 Web Server。确实很小，把几个 java 文件引入项目即可，该库也有实现了 Seekable Content 服务的代码，目前他是以源码的形式发布。使用方便，不过在开发后期的代码检查和分析里（Inspection）会有不少警告，该库提升空间比较大，例如下面源码里的一行代码（NanoHTTPD.java 第 651 行）\n  this.remoteIp = inetAddress.isLoopbackAddress() || inetAddress.isAnyLocalAddress() ? \u0026#34;127.0.0.1\u0026#34; : inetAddress.getHostAddress().toString(); /* 该行是要得到一个地址字符串给 remoteIp（String 类型），inetAddress.getHostAddress() 返回的已经是 String 类型， 但是这里是调用了 String.toString 来返回一个 String。 */ 5. 结束 以前做过一个 DLNA/UPnP 全功能的 Android 播放器 APP，使用 Android 系统 MediaPlayer 做媒体播放，用多媒体数据库来构建播放器媒体库，用 Apache Httpd 来支持 Http 在线媒体访问。断断续续的更新了几个版本，启用了 Material Design，优化了 UPnP 操作，播放核心换成支持硬解的 VLC，使用 NanoHTTPD 作为新的 Http 服务器。\n虽然有安全性的忧虑，但是在标准化和广泛的设备支持下，我觉得 UPnP 在家庭网络上还是有一些可能性。\n参考资料\n UPnP Device Architecture 2.0 http://upnp.org/specs/arch/UPnP-arch-DeviceArchitecture-v2.0.pdf\nDLNA Guidelines https://spirespark.com/dlna/guidelines/\nOpen Connectivity https://openconnectivity.org/\nCling UPnP Stack https://github.com/4thline/cling/\nNanoHTTPD https://github.com/NanoHttpd/nanohttpd/\nVLC https://www.videolan.org/\n","permalink":"https://xinlake.dev/blog/2017/07-mouter/","tags":["UPnP","HTTP","Cling"],"title":"UPnP 媒体互联，为播放器添加 DLNA/UPnP 功能"},{"categories":["Lifestyle"],"contents":"很高兴，终于在 GitHub 上搭建起了我的个人博客。看了不少博客方案，最终选用了对 Windows 系统更加友好的 Hexo 博客框架，主题是默认的 landscape。这是我的第一篇博客，向世界打个招呼 “Hello World！”\n","permalink":"https://xinlake.dev/blog/2017/07-hello-world/","tags":["Blog"],"title":"你好，世界"}]